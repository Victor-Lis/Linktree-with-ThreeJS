let t,e,i,s,o,n,r;var a=globalThis,l={},h={},c=a.parcelRequirebe84;null==c&&((c=function(t){if(t in l)return l[t].exports;if(t in h){var e=h[t];delete h[t];var i={id:t,exports:{}};return l[t]=i,e.call(i.exports,i,i.exports),i.exports}var s=Error("Cannot find module '"+t+"'");throw s.code="MODULE_NOT_FOUND",s}).register=function(t,e){h[t]=e},a.parcelRequirebe84=c),c.register;var d=c("jPmIf");c("e93rA");var u=c("dbKDE"),d=c("jPmIf");class p{constructor(t){void 0===t&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){let t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){let t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){let e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){void 0===t&&(t=new v);let e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){void 0===e&&(e=new v);let i=this.elements,s=t.x,o=t.y,n=t.z;return e.x=i[0]*s+i[1]*o+i[2]*n,e.y=i[3]*s+i[4]*o+i[5]*n,e.z=i[6]*s+i[7]*o+i[8]*n,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){void 0===e&&(e=new p);let i=this.elements,s=t.elements,o=e.elements,n=i[0],r=i[1],a=i[2],l=i[3],h=i[4],c=i[5],d=i[6],u=i[7],y=i[8],v=s[0],m=s[1],w=s[2],f=s[3],g=s[4],b=s[5],x=s[6],E=s[7],z=s[8];return o[0]=n*v+r*f+a*x,o[1]=n*m+r*g+a*E,o[2]=n*w+r*b+a*z,o[3]=l*v+h*f+c*x,o[4]=l*m+h*g+c*E,o[5]=l*w+h*b+c*z,o[6]=d*v+u*f+y*x,o[7]=d*m+u*g+y*E,o[8]=d*w+u*b+y*z,e}scale(t,e){void 0===e&&(e=new p);let i=this.elements,s=e.elements;for(let e=0;3!==e;e++)s[3*e+0]=t.x*i[3*e+0],s[3*e+1]=t.y*i[3*e+1],s[3*e+2]=t.z*i[3*e+2];return e}solve(t,e){let i,s,o,n;void 0===e&&(e=new v);let r=[];for(i=0;i<12;i++)r.push(0);for(i=0;i<3;i++)for(s=0;s<3;s++)r[i+4*s]=this.elements[i+3*s];r[3]=t.x,r[7]=t.y,r[11]=t.z;let a=3;do{if(0===r[(i=3-a)+4*i]){for(s=i+1;s<3;s++)if(0!==r[i+4*s]){o=4;do n=4-o,r[n+4*i]+=r[n+4*s];while(--o)break}}if(0!==r[i+4*i])for(s=i+1;s<3;s++){let t=r[i+4*s]/r[i+4*i];o=4;do r[(n=4-o)+4*s]=n<=i?0:r[n+4*s]-r[n+4*i]*t;while(--o)}}while(--a)if(e.z=r[11]/r[10],e.y=(r[7]-r[6]*e.z)/r[5],e.x=(r[3]-r[2]*e.z-r[1]*e.y)/r[0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,i){if(void 0===i)return this.elements[e+3*t];this.elements[e+3*t]=i}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";for(let e=0;e<9;e++)t+=this.elements[e]+",";return t}reverse(t){let e,i,s,o;for(void 0===t&&(t=new p),e=0;e<3;e++)for(i=0;i<3;i++)y[e+6*i]=this.elements[e+3*i];y[3]=1,y[9]=0,y[15]=0,y[4]=0,y[10]=1,y[16]=0,y[5]=0,y[11]=0,y[17]=1;let n=3;do{if(0===y[(e=3-n)+6*e]){for(i=e+1;i<3;i++)if(0!==y[e+6*i]){s=6;do o=6-s,y[o+6*e]+=y[o+6*i];while(--s)break}}if(0!==y[e+6*e])for(i=e+1;i<3;i++){let t=y[e+6*i]/y[e+6*e];s=6;do y[(o=6-s)+6*i]=o<=e?0:y[o+6*i]-y[o+6*e]*t;while(--s)}}while(--n)e=2;do{i=e-1;do{let t=y[e+6*i]/y[e+6*e];s=6;do y[(o=6-s)+6*i]=y[o+6*i]-y[o+6*e]*t;while(--s)}while(i--)}while(--e)e=2;do{let t=1/y[e+6*e];s=6;do y[(o=6-s)+6*e]=y[o+6*e]*t;while(--s)}while(e--)e=2;do{i=2;do{if(isNaN(o=y[3+i+6*e])||o===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(e,i,o)}while(i--)}while(e--)return t}setRotationFromQuaternion(t){let e=t.x,i=t.y,s=t.z,o=t.w,n=e+e,r=i+i,a=s+s,l=e*n,h=e*r,c=e*a,d=i*r,u=i*a,p=s*a,y=o*n,v=o*r,m=o*a,w=this.elements;return w[0]=1-(d+p),w[1]=h-m,w[2]=c+v,w[3]=h+m,w[4]=1-(l+p),w[5]=u-y,w[6]=c-v,w[7]=u+y,w[8]=1-(l+d),this}transpose(t){let e;void 0===t&&(t=new p);let i=this.elements,s=t.elements;return s[0]=i[0],s[4]=i[4],s[8]=i[8],e=i[1],s[1]=i[3],s[3]=e,e=i[2],s[2]=i[6],s[6]=e,e=i[5],s[5]=i[7],s[7]=e,t}}const y=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class v{constructor(t,e,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),this.x=t,this.y=e,this.z=i}cross(t,e){void 0===e&&(e=new v);let i=t.x,s=t.y,o=t.z,n=this.x,r=this.y,a=this.z;return e.x=r*o-a*s,e.y=a*i-n*o,e.z=n*s-r*i,e}set(t,e,i){return this.x=t,this.y=e,this.z=i,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(!e)return new v(this.x+t.x,this.y+t.y,this.z+t.z);e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z}vsub(t,e){if(!e)return new v(this.x-t.x,this.y-t.y,this.z-t.z);e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z}crossmat(){return new p([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){let t=this.x,e=this.y,i=this.z,s=Math.sqrt(t*t+e*e+i*i);if(s>0){let t=1/s;this.x*=t,this.y*=t,this.z*=t}else this.x=0,this.y=0,this.z=0;return s}unit(t){void 0===t&&(t=new v);let e=this.x,i=this.y,s=this.z,o=Math.sqrt(e*e+i*i+s*s);return o>0?(o=1/o,t.x=e*o,t.y=i*o,t.z=s*o):(t.x=1,t.y=0,t.z=0),t}length(){let t=this.x,e=this.y,i=this.z;return Math.sqrt(t*t+e*e+i*i)}lengthSquared(){return this.dot(this)}distanceTo(t){let e=this.x,i=this.y,s=this.z,o=t.x,n=t.y,r=t.z;return Math.sqrt((o-e)*(o-e)+(n-i)*(n-i)+(r-s)*(r-s))}distanceSquared(t){let e=this.x,i=this.y,s=this.z,o=t.x,n=t.y,r=t.z;return(o-e)*(o-e)+(n-i)*(n-i)+(r-s)*(r-s)}scale(t,e){void 0===e&&(e=new v);let i=this.x,s=this.y,o=this.z;return e.x=t*i,e.y=t*s,e.z=t*o,e}vmul(t,e){return void 0===e&&(e=new v),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,i){return void 0===i&&(i=new v),i.x=this.x+t*e.x,i.y=this.y+t*e.y,i.z=this.z+t*e.z,i}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(t){return void 0===t&&(t=new v),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){let i=this.length();if(i>0){let s=1/i;m.set(this.x*s,this.y*s,this.z*s),.9>Math.abs(m.x)?w.set(1,0,0):w.set(0,1,0),m.cross(w,t),m.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,i){let s=this.x,o=this.y,n=this.z;i.x=s+(t.x-s)*e,i.y=o+(t.y-o)*e,i.z=n+(t.z-n)*e}almostEquals(t,e){return void 0===e&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return void 0===t&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(f),f.almostEquals(t,e)}clone(){return new v(this.x,this.y,this.z)}}v.ZERO=new v(0,0,0),v.UNIT_X=new v(1,0,0),v.UNIT_Y=new v(0,1,0),v.UNIT_Z=new v(0,0,1);const m=new v,w=new v,f=new v;class g{constructor(t){void 0===t&&(t={}),this.lowerBound=new v,this.upperBound=new v,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,i,s){let o=this.lowerBound,n=this.upperBound;o.copy(t[0]),i&&i.vmult(o,o),n.copy(o);for(let e=1;e<t.length;e++){let s=t[e];i&&(i.vmult(s,b),s=b),s.x>n.x&&(n.x=s.x),s.x<o.x&&(o.x=s.x),s.y>n.y&&(n.y=s.y),s.y<o.y&&(o.y=s.y),s.z>n.z&&(n.z=s.z),s.z<o.z&&(o.z=s.z)}return e&&(e.vadd(o,o),e.vadd(n,n)),s&&(o.x-=s,o.y-=s,o.z-=s,n.x+=s,n.y+=s,n.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new g().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,o=t.upperBound,n=s.x<=i.x&&i.x<=o.x||e.x<=o.x&&o.x<=i.x,r=s.y<=i.y&&i.y<=o.y||e.y<=o.y&&o.y<=i.y,a=s.z<=i.z&&i.z<=o.z||e.z<=o.z&&o.z<=i.z;return n&&r&&a}volume(){let t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,o=t.upperBound;return e.x<=s.x&&i.x>=o.x&&e.y<=s.y&&i.y>=o.y&&e.z<=s.z&&i.z>=o.z}getCorners(t,e,i,s,o,n,r,a){let l=this.lowerBound,h=this.upperBound;t.copy(l),e.set(h.x,l.y,l.z),i.set(h.x,h.y,l.z),s.set(l.x,h.y,h.z),o.set(h.x,l.y,h.z),n.set(l.x,h.y,l.z),r.set(l.x,l.y,h.z),a.copy(h)}toLocalFrame(t,e){let i=x[0],s=x[1],o=x[2],n=x[3],r=x[4],a=x[5],l=x[6],h=x[7];this.getCorners(i,s,o,n,r,a,l,h);for(let e=0;8!==e;e++){let i=x[e];t.pointToLocal(i,i)}return e.setFromPoints(x)}toWorldFrame(t,e){let i=x[0],s=x[1],o=x[2],n=x[3],r=x[4],a=x[5],l=x[6],h=x[7];this.getCorners(i,s,o,n,r,a,l,h);for(let e=0;8!==e;e++){let i=x[e];t.pointToWorld(i,i)}return e.setFromPoints(x)}overlapsRay(t){let{direction:e,from:i}=t,s=1/e.x,o=1/e.y,n=1/e.z,r=(this.lowerBound.x-i.x)*s,a=(this.upperBound.x-i.x)*s,l=(this.lowerBound.y-i.y)*o,h=(this.upperBound.y-i.y)*o,c=(this.lowerBound.z-i.z)*n,d=(this.upperBound.z-i.z)*n,u=Math.min(Math.min(Math.max(r,a),Math.max(l,h)),Math.max(c,d));return!(u<0||Math.max(Math.max(Math.min(r,a),Math.min(l,h)),Math.min(c,d))>u)}}const b=new v,x=[new v,new v,new v,new v,new v,new v,new v,new v];class E{constructor(){this.matrix=[]}get(t,e){let{index:i}=t,{index:s}=e;if(s>i){let t=s;s=i,i=t}return this.matrix[(i*(i+1)>>1)+s-1]}set(t,e,i){let{index:s}=t,{index:o}=e;if(o>s){let t=o;o=s,s=t}this.matrix[(s*(s+1)>>1)+o-1]=i?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class z{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});let i=this._listeners;return void 0===i[t]&&(i[t]=[]),i[t].includes(e)||i[t].push(e),this}hasEventListener(t,e){if(void 0===this._listeners)return!1;let i=this._listeners;return!!(void 0!==i[t]&&i[t].includes(e))}hasAnyEventListener(t){return void 0!==this._listeners&&void 0!==this._listeners[t]}removeEventListener(t,e){if(void 0===this._listeners)return this;let i=this._listeners;if(void 0===i[t])return this;let s=i[t].indexOf(e);return -1!==s&&i[t].splice(s,1),this}dispatchEvent(t){if(void 0===this._listeners)return this;let e=this._listeners[t.type];if(void 0!==e){t.target=this;for(let i=0,s=e.length;i<s;i++)e[i].call(this,t)}return this}}class C{constructor(t,e,i,s){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=1),this.x=t,this.y=e,this.z=i,this.w=s}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){let i=Math.sin(.5*e);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(.5*e),this}toAxisAngle(t){void 0===t&&(t=new v),this.normalize();let e=2*Math.acos(this.w),i=Math.sqrt(1-this.w*this.w);return i<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/i,t.y=this.y/i,t.z=this.z/i),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e))t.tangents(S,M),this.setFromAxisAngle(S,Math.PI);else{let i=t.cross(e);this.x=i.x,this.y=i.y,this.z=i.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){void 0===e&&(e=new C);let i=this.x,s=this.y,o=this.z,n=this.w,r=t.x,a=t.y,l=t.z,h=t.w;return e.x=i*h+n*r+s*l-o*a,e.y=s*h+n*a+o*r-i*l,e.z=o*h+n*l+i*a-s*r,e.w=n*h-i*r-s*a-o*l,e}inverse(t){void 0===t&&(t=new C);let e=this.x,i=this.y,s=this.z,o=this.w;this.conjugate(t);let n=1/(e*e+i*i+s*s+o*o);return t.x*=n,t.y*=n,t.z*=n,t.w*=n,t}conjugate(t){return void 0===t&&(t=new C),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){let t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){void 0===e&&(e=new v);let i=t.x,s=t.y,o=t.z,n=this.x,r=this.y,a=this.z,l=this.w,h=l*i+r*o-a*s,c=l*s+a*i-n*o,d=l*o+n*s-r*i,u=-n*i-r*s-a*o;return e.x=h*l+-(u*n)+-(c*a)- -(d*r),e.y=c*l+-(u*r)+-(d*n)- -(h*a),e.z=d*l+-(u*a)+-(h*r)- -(c*n),e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){let i,s,o;void 0===e&&(e="YZX");let n=this.x,r=this.y,a=this.z,l=this.w;if("YZX"===e){let t=n*r+a*l;if(t>.499&&(i=2*Math.atan2(n,l),s=Math.PI/2,o=0),t<-.499&&(i=-2*Math.atan2(n,l),s=-Math.PI/2,o=0),void 0===i){let e=a*a;i=Math.atan2(2*r*l-2*n*a,1-r*r*2-2*e),s=Math.asin(2*t),o=Math.atan2(2*n*l-2*r*a,1-n*n*2-2*e)}}else throw Error(`Euler order ${e} not supported yet.`);t.y=i,t.z=s,t.x=o}setFromEuler(t,e,i,s){void 0===s&&(s="XYZ");let o=Math.cos(t/2),n=Math.cos(e/2),r=Math.cos(i/2),a=Math.sin(t/2),l=Math.sin(e/2),h=Math.sin(i/2);return"XYZ"===s?(this.x=a*n*r+o*l*h,this.y=o*l*r-a*n*h,this.z=o*n*h+a*l*r,this.w=o*n*r-a*l*h):"YXZ"===s?(this.x=a*n*r+o*l*h,this.y=o*l*r-a*n*h,this.z=o*n*h-a*l*r,this.w=o*n*r+a*l*h):"ZXY"===s?(this.x=a*n*r-o*l*h,this.y=o*l*r+a*n*h,this.z=o*n*h+a*l*r,this.w=o*n*r-a*l*h):"ZYX"===s?(this.x=a*n*r-o*l*h,this.y=o*l*r+a*n*h,this.z=o*n*h-a*l*r,this.w=o*n*r+a*l*h):"YZX"===s?(this.x=a*n*r+o*l*h,this.y=o*l*r+a*n*h,this.z=o*n*h-a*l*r,this.w=o*n*r-a*l*h):"XZY"===s&&(this.x=a*n*r-o*l*h,this.y=o*l*r-a*n*h,this.z=o*n*h+a*l*r,this.w=o*n*r+a*l*h),this}clone(){return new C(this.x,this.y,this.z,this.w)}slerp(t,e,i){let s,o,n,r,a;void 0===i&&(i=new C);let l=this.x,h=this.y,c=this.z,d=this.w,u=t.x,p=t.y,y=t.z,v=t.w;return(o=l*u+h*p+c*y+d*v)<0&&(o=-o,u=-u,p=-p,y=-y,v=-v),1-o>1e-6?(n=Math.sin(s=Math.acos(o)),r=Math.sin((1-e)*s)/n,a=Math.sin(e*s)/n):(r=1-e,a=e),i.x=r*l+a*u,i.y=r*h+a*p,i.z=r*c+a*y,i.w=r*d+a*v,i}integrate(t,e,i,s){void 0===s&&(s=new C);let o=t.x*i.x,n=t.y*i.y,r=t.z*i.z,a=this.x,l=this.y,h=this.z,c=this.w,d=.5*e;return s.x+=d*(o*c+n*h-r*l),s.y+=d*(n*c+r*a-o*h),s.z+=d*(r*c+o*l-n*a),s.w+=d*(-o*a-n*l-r*h),s}}const S=new v,M=new v;class q{constructor(t){void 0===t&&(t={}),this.id=q.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=!t.collisionResponse||t.collisionResponse,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,i,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}q.idCounter=0,q.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class B{constructor(t){void 0===t&&(t={}),this.position=new v,this.quaternion=new C,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return B.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return B.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return void 0===e&&(e=new v),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,i,s){return void 0===s&&(s=new v),i.vsub(t,s),e.conjugate(P),P.vmult(s,s),s}static pointToWorldFrame(t,e,i,s){return void 0===s&&(s=new v),e.vmult(i,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,i){return void 0===i&&(i=new v),t.vmult(e,i),i}static vectorToLocalFrame(t,e,i,s){return void 0===s&&(s=new v),e.w*=-1,e.vmult(i,s),e.w*=-1,s}}const P=new C;class A extends q{constructor(t){void 0===t&&(t={});let{vertices:e=[],faces:i=[],normals:s=[],axes:o,boundingSphereRadius:n}=t;super({type:q.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=i,this.faceNormals=s,0===this.faceNormals.length&&this.computeNormals(),n?this.boundingSphereRadius=n:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=o?o.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){let t=this.faces,e=this.vertices,i=this.uniqueEdges;i.length=0;let s=new v;for(let o=0;o!==t.length;o++){let n=t[o],r=n.length;for(let t=0;t!==r;t++){let o=(t+1)%r;e[n[t]].vsub(e[n[o]],s),s.normalize();let a=!1;for(let t=0;t!==i.length;t++)if(i[t].almostEquals(s)||i[t].almostEquals(s)){a=!0;break}a||i.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let e=0;e<this.faces[t].length;e++)if(!this.vertices[this.faces[t][e]])throw Error(`Vertex ${this.faces[t][e]} not found!`);let e=this.faceNormals[t]||new v;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;let i=this.vertices[this.faces[t][0]];if(0>e.dot(i)){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let e=0;e<this.faces[t].length;e++)console.warn(`.vertices[${this.faces[t][e]}] = Vec3(${this.vertices[this.faces[t][e]].toString()})`)}}}getFaceNormal(t,e){let i=this.faces[t],s=this.vertices[i[0]],o=this.vertices[i[1]],n=this.vertices[i[2]];A.computeNormal(s,o,n,e)}static computeNormal(t,e,i,s){let o=new v,n=new v;e.vsub(t,n),i.vsub(e,o),o.cross(n,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,i,s,o,n,r,a,l){let h=new v,c=-1,d=-Number.MAX_VALUE;for(let t=0;t<i.faces.length;t++){h.copy(i.faceNormals[t]),o.vmult(h,h);let e=h.dot(n);e>d&&(d=e,c=t)}let u=[];for(let t=0;t<i.faces[c].length;t++){let e=i.vertices[i.faces[c][t]],n=new v;n.copy(e),o.vmult(n,n),s.vadd(n,n),u.push(n)}c>=0&&this.clipFaceAgainstHull(n,t,e,u,r,a,l)}findSeparatingAxis(t,e,i,s,o,n,r,a){let l=new v,h=new v,c=new v,d=new v,u=new v,p=new v,y=Number.MAX_VALUE;if(this.uniqueAxes)for(let r=0;r!==this.uniqueAxes.length;r++){i.vmult(this.uniqueAxes[r],l);let a=this.testSepAxis(l,t,e,i,s,o);if(!1===a)return!1;a<y&&(y=a,n.copy(l))}else{let a=r?r.length:this.faces.length;for(let h=0;h<a;h++){let a=r?r[h]:h;l.copy(this.faceNormals[a]),i.vmult(l,l);let c=this.testSepAxis(l,t,e,i,s,o);if(!1===c)return!1;c<y&&(y=c,n.copy(l))}}if(t.uniqueAxes)for(let r=0;r!==t.uniqueAxes.length;r++){o.vmult(t.uniqueAxes[r],h);let a=this.testSepAxis(h,t,e,i,s,o);if(!1===a)return!1;a<y&&(y=a,n.copy(h))}else{let r=a?a.length:t.faces.length;for(let l=0;l<r;l++){let r=a?a[l]:l;h.copy(t.faceNormals[r]),o.vmult(h,h);let c=this.testSepAxis(h,t,e,i,s,o);if(!1===c)return!1;c<y&&(y=c,n.copy(h))}}for(let r=0;r!==this.uniqueEdges.length;r++){i.vmult(this.uniqueEdges[r],d);for(let r=0;r!==t.uniqueEdges.length;r++)if(o.vmult(t.uniqueEdges[r],u),d.cross(u,p),!p.almostZero()){p.normalize();let r=this.testSepAxis(p,t,e,i,s,o);if(!1===r)return!1;r<y&&(y=r,n.copy(p))}}return s.vsub(e,c),c.dot(n)>0&&n.negate(n),!0}testSepAxis(t,e,i,s,o,n){A.project(this,t,i,s,F),A.project(e,t,o,n,I);let r=F[0],a=F[1],l=I[0],h=I[1];if(r<h||l<a)return!1;let c=r-h,d=l-a;return c<d?c:d}calculateLocalInertia(t,e){let i=new v,s=new v;this.computeLocalAABB(s,i);let o=i.x-s.x,n=i.y-s.y,r=i.z-s.z;e.x=1/12*t*(2*n*2*n+2*r*2*r),e.y=1/12*t*(2*o*2*o+2*r*2*r),e.z=1/12*t*(2*n*2*n+2*o*2*o)}getPlaneConstantOfFace(t){let e=this.faces[t],i=this.faceNormals[t],s=this.vertices[e[0]];return-i.dot(s)}clipFaceAgainstHull(t,e,i,s,o,n,r){let a=new v,l=new v,h=new v,c=new v,d=new v,u=new v,p=new v,y=new v,m=[],w=-1,f=Number.MAX_VALUE;for(let e=0;e<this.faces.length;e++){a.copy(this.faceNormals[e]),i.vmult(a,a);let s=a.dot(t);s<f&&(f=s,w=e)}if(w<0)return;let g=this.faces[w];g.connectedFaces=[];for(let t=0;t<this.faces.length;t++)for(let e=0;e<this.faces[t].length;e++)-1!==g.indexOf(this.faces[t][e])&&t!==w&&-1===g.connectedFaces.indexOf(t)&&g.connectedFaces.push(t);let b=g.length;for(let t=0;t<b;t++){let o=this.vertices[g[t]],n=this.vertices[g[(t+1)%b]];o.vsub(n,l),h.copy(l),i.vmult(h,h),e.vadd(h,h),c.copy(this.faceNormals[w]),i.vmult(c,c),e.vadd(c,c),h.cross(c,d),d.negate(d),u.copy(o),i.vmult(u,u),e.vadd(u,u);let r=g.connectedFaces[t];p.copy(this.faceNormals[r]);let a=this.getPlaneConstantOfFace(r);y.copy(p),i.vmult(y,y);let v=a-y.dot(e);for(this.clipFaceAgainstPlane(s,m,y,v);s.length;)s.shift();for(;m.length;)s.push(m.shift())}p.copy(this.faceNormals[w]);let x=this.getPlaneConstantOfFace(w);y.copy(p),i.vmult(y,y);let E=x-y.dot(e);for(let t=0;t<s.length;t++){let e=y.dot(s[t])+E;if(e<=o&&(console.log(`clamped: depth=${e} to minDist=${o}`),e=o),e<=n){let i=s[t];if(e<=1e-6){let t={point:i,normal:y,depth:e};r.push(t)}}}}clipFaceAgainstPlane(t,e,i,s){let o,n;let r=t.length;if(r<2)return e;let a=t[t.length-1],l=t[0];o=i.dot(a)+s;for(let h=0;h<r;h++){if(l=t[h],n=i.dot(l)+s,o<0){if(n<0){let t=new v;t.copy(l),e.push(t)}else{let t=new v;a.lerp(l,o/(o-n),t),e.push(t)}}else if(n<0){let t=new v;a.lerp(l,o/(o-n),t),e.push(t),e.push(l)}a=l,o=n}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new v);let i=this.vertices,s=this.worldVertices;for(let o=0;o!==this.vertices.length;o++)e.vmult(i[o],s[o]),t.vadd(s[o],s[o]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){let i=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){let o=i[s];o.x<t.x?t.x=o.x:o.x>e.x&&(e.x=o.x),o.y<t.y?t.y=o.y:o.y>e.y&&(e.y=o.y),o.z<t.z?t.z=o.z:o.z>e.z&&(e.z=o.z)}}computeWorldFaceNormals(t){let e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new v);let i=this.faceNormals,s=this.worldFaceNormals;for(let o=0;o!==e;o++)t.vmult(i[o],s[o]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0,e=this.vertices;for(let i=0;i!==e.length;i++){let s=e[i].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,i,s){let o,n,r,a,l,h;let c=this.vertices,d=new v;for(let i=0;i<c.length;i++)d.copy(c[i]),e.vmult(d,d),t.vadd(d,d),(void 0===o||d.x<o)&&(o=d.x),(void 0===a||d.x>a)&&(a=d.x),(void 0===n||d.y<n)&&(n=d.y),(void 0===l||d.y>l)&&(l=d.y),(void 0===r||d.z<r)&&(r=d.z),(void 0===h||d.z>h)&&(h=d.z);i.set(o,n,r),s.set(a,l,h)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){void 0===t&&(t=new v);let e=this.vertices;for(let i=0;i<e.length;i++)t.vadd(e[i],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){let i=this.vertices.length,s=this.vertices;if(e){for(let t=0;t<i;t++){let i=s[t];e.vmult(i,i)}for(let t=0;t<this.faceNormals.length;t++){let i=this.faceNormals[t];e.vmult(i,i)}}if(t)for(let e=0;e<i;e++){let i=s[e];i.vadd(t,i)}}pointIsInside(t){let e=this.vertices,i=this.faces,s=this.faceNormals,o=new v;this.getAveragePointLocal(o);for(let n=0;n<this.faces.length;n++){let r=s[n],a=e[i[n][0]],l=new v;t.vsub(a,l);let h=r.dot(l),c=new v;o.vsub(a,c);let d=r.dot(c);if(h<0&&d>0||h>0&&d<0)return!1}return -1}static project(t,e,i,s,o){let n=t.vertices.length,r=0,a=0,l=t.vertices;N.setZero(),B.vectorToLocalFrame(i,s,e,T),B.pointToLocalFrame(i,s,N,N);let h=N.dot(T);a=r=l[0].dot(T);for(let t=1;t<n;t++){let e=l[t].dot(T);e>r&&(r=e),e<a&&(a=e)}if((a-=h)>(r-=h)){let t=a;a=r,r=t}o[0]=r,o[1]=a}}const F=[],I=[];new v;const T=new v,N=new v;class R extends q{constructor(t){super({type:q.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){let t=this.halfExtents.x,e=this.halfExtents.y,i=this.halfExtents.z,s=new A({vertices:[new v(-t,-e,-i),new v(t,-e,-i),new v(t,e,-i),new v(-t,e,-i),new v(-t,-e,i),new v(t,-e,i),new v(t,e,i),new v(-t,e,i)],faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:[new v(0,0,1),new v(0,1,0),new v(1,0,0)]});this.convexPolyhedronRepresentation=s,s.material=this.material}calculateLocalInertia(t,e){return void 0===e&&(e=new v),R.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,i){i.x=1/12*e*(2*t.y*2*t.y+2*t.z*2*t.z),i.y=1/12*e*(2*t.x*2*t.x+2*t.z*2*t.z),i.z=1/12*e*(2*t.y*2*t.y+2*t.x*2*t.x)}getSideNormals(t,e){let i=this.halfExtents;if(t[0].set(i.x,0,0),t[1].set(0,i.y,0),t[2].set(0,0,i.z),t[3].set(-i.x,0,0),t[4].set(0,-i.y,0),t[5].set(0,0,-i.z),void 0!==e)for(let i=0;i!==t.length;i++)e.vmult(t[i],t[i]);return t}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,i){let s=this.halfExtents,o=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let s=0;s<o.length;s++)L.set(o[s][0],o[s][1],o[s][2]),e.vmult(L,L),t.vadd(L,L),i(L.x,L.y,L.z)}calculateWorldAABB(t,e,i,s){let o=this.halfExtents;j[0].set(o.x,o.y,o.z),j[1].set(-o.x,o.y,o.z),j[2].set(-o.x,-o.y,o.z),j[3].set(-o.x,-o.y,-o.z),j[4].set(o.x,-o.y,-o.z),j[5].set(o.x,o.y,-o.z),j[6].set(-o.x,o.y,-o.z),j[7].set(o.x,-o.y,o.z);let n=j[0];e.vmult(n,n),t.vadd(n,n),s.copy(n),i.copy(n);for(let o=1;o<8;o++){let n=j[o];e.vmult(n,n),t.vadd(n,n);let r=n.x,a=n.y,l=n.z;r>s.x&&(s.x=r),a>s.y&&(s.y=a),l>s.z&&(s.z=l),r<i.x&&(i.x=r),a<i.y&&(i.y=a),l<i.z&&(i.z=l)}}}const L=new v,j=[new v,new v,new v,new v,new v,new v,new v,new v],k={DYNAMIC:1,STATIC:2,KINEMATIC:4},W={AWAKE:0,SLEEPY:1,SLEEPING:2};class O extends z{constructor(t){void 0===t&&(t={}),super(),this.id=O.idCounter++,this.index=-1,this.world=null,this.vlambda=new v,this.collisionFilterGroup="number"==typeof t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof t.collisionResponse||t.collisionResponse,this.position=new v,this.previousPosition=new v,this.interpolatedPosition=new v,this.initPosition=new v,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new v,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new v,this.force=new v;let e="number"==typeof t.mass?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping="number"==typeof t.linearDamping?t.linearDamping:.01,this.type=e<=0?O.STATIC:O.DYNAMIC,typeof t.type==typeof O.STATIC&&(this.type=t.type),this.allowSleep=void 0===t.allowSleep||t.allowSleep,this.sleepState=O.AWAKE,this.sleepSpeedLimit=void 0!==t.sleepSpeedLimit?t.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==t.sleepTimeLimit?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new v,this.quaternion=new C,this.initQuaternion=new C,this.previousQuaternion=new C,this.interpolatedQuaternion=new C,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new v,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new v,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new v,this.invInertia=new v,this.invInertiaWorld=new p,this.invMassSolve=0,this.invInertiaSolve=new v,this.invInertiaWorldSolve=new p,this.fixedRotation=void 0!==t.fixedRotation&&t.fixedRotation,this.angularDamping=void 0!==t.angularDamping?t.angularDamping:.01,this.linearFactor=new v(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new v(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new g,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new v,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){let t=this.sleepState;this.sleepState=O.AWAKE,this.wakeUpAfterNarrowphase=!1,t===O.SLEEPING&&this.dispatchEvent(O.wakeupEvent)}sleep(){this.sleepState=O.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){let e=this.sleepState,i=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===O.AWAKE&&i<s?(this.sleepState=O.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(O.sleepyEvent)):e===O.SLEEPY&&i>s?this.wakeUp():e===O.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(O.sleepEvent))}}updateSolveMassProperties(){this.sleepState===O.SLEEPING||this.type===O.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return void 0===e&&(e=new v),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return void 0===e&&(e=new v),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return void 0===e&&(e=new v),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return void 0===e&&(e=new v),this.quaternion.vmult(t,e),e}addShape(t,e,i){let s=new v,o=new C;return e&&s.copy(e),i&&o.copy(i),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(o),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){let e=this.shapes.indexOf(t);return -1===e?console.warn("Shape does not belong to the body"):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null),this}updateBoundingRadius(){let t=this.shapes,e=this.shapeOffsets,i=t.length,s=0;for(let o=0;o!==i;o++){let i=t[o];i.updateBoundingSphereRadius();let n=e[o].length(),r=i.boundingSphereRadius;n+r>s&&(s=n+r)}this.boundingRadius=s}updateAABB(){let t=this.shapes,e=this.shapeOffsets,i=this.shapeOrientations,s=t.length,o=this.quaternion,n=this.aabb;for(let r=0;r!==s;r++){let s=t[r];o.vmult(e[r],V),V.vadd(this.position,V),o.mult(i[r],D),s.calculateWorldAABB(V,D,H.lowerBound,H.upperBound),0===r?n.copy(H):n.extend(H)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){let e=this.invInertia;(e.x!==e.y||e.y!==e.z||t)&&(G.setRotationFromQuaternion(this.quaternion),G.transpose(Y),G.scale(e,G),G.mmult(Y,this.invInertiaWorld))}applyForce(t,e){void 0===e&&(e=new v),this.type===O.DYNAMIC&&(this.sleepState===O.SLEEPING&&this.wakeUp(),e.cross(t,X),this.force.vadd(t,this.force),this.torque.vadd(X,this.torque))}applyLocalForce(t,e){void 0===e&&(e=new v),this.type===O.DYNAMIC&&(this.vectorToWorldFrame(t,U),this.vectorToWorldFrame(e,_),this.applyForce(U,_))}applyTorque(t){this.type===O.DYNAMIC&&(this.sleepState===O.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(void 0===e&&(e=new v),this.type!==O.DYNAMIC)return;this.sleepState===O.SLEEPING&&this.wakeUp();let i=e;Z.copy(t),Z.scale(this.invMass,Z),this.velocity.vadd(Z,this.velocity),i.cross(t,K),this.invInertiaWorld.vmult(K,K),this.angularVelocity.vadd(K,this.angularVelocity)}applyLocalImpulse(t,e){void 0===e&&(e=new v),this.type===O.DYNAMIC&&(this.vectorToWorldFrame(t,$),this.vectorToWorldFrame(e,Q),this.applyImpulse($,Q))}updateMassProperties(){this.invMass=this.mass>0?1/this.mass:0;let t=this.inertia,e=this.fixedRotation;this.updateAABB(),J.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),R.calculateInertia(J,this.mass,t),this.invInertia.set(t.x>0&&!e?1/t.x:0,t.y>0&&!e?1/t.y:0,t.z>0&&!e?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){let i=new v;return t.vsub(this.position,i),this.angularVelocity.cross(i,e),this.velocity.vadd(e,e),e}integrate(t,e,i){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===O.DYNAMIC||this.type===O.KINEMATIC)||this.sleepState===O.SLEEPING)return;let s=this.velocity,o=this.angularVelocity,n=this.position,r=this.force,a=this.torque,l=this.quaternion,h=this.invMass,c=this.invInertiaWorld,d=this.linearFactor,u=h*t;s.x+=r.x*u*d.x,s.y+=r.y*u*d.y,s.z+=r.z*u*d.z;let p=c.elements,y=this.angularFactor,v=a.x*y.x,m=a.y*y.y,w=a.z*y.z;o.x+=t*(p[0]*v+p[1]*m+p[2]*w),o.y+=t*(p[3]*v+p[4]*m+p[5]*w),o.z+=t*(p[6]*v+p[7]*m+p[8]*w),n.x+=s.x*t,n.y+=s.y*t,n.z+=s.z*t,l.integrate(this.angularVelocity,t,this.angularFactor,l),e&&(i?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}O.idCounter=0,O.COLLIDE_EVENT_NAME="collide",O.DYNAMIC=k.DYNAMIC,O.STATIC=k.STATIC,O.KINEMATIC=k.KINEMATIC,O.AWAKE=W.AWAKE,O.SLEEPY=W.SLEEPY,O.SLEEPING=W.SLEEPING,O.wakeupEvent={type:"wakeup"},O.sleepyEvent={type:"sleepy"},O.sleepEvent={type:"sleep"};const V=new v,D=new C,H=new g,G=new p,Y=new p;new p;const X=new v,U=new v,_=new v,Z=new v,K=new v,$=new v,Q=new v,J=new v;class tt{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,i){throw Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return(t.collisionFilterGroup&e.collisionFilterMask)!=0&&(e.collisionFilterGroup&t.collisionFilterMask)!=0&&((t.type&O.STATIC)==0&&t.sleepState!==O.SLEEPING||(e.type&O.STATIC)==0&&e.sleepState!==O.SLEEPING)}intersectionTest(t,e,i,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,i,s):this.doBoundingSphereBroadphase(t,e,i,s)}doBoundingSphereBroadphase(t,e,i,s){e.position.vsub(t.position,te);let o=(t.boundingRadius+e.boundingRadius)**2;te.lengthSquared()<o&&(i.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,i,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(i.push(t),s.push(e))}makePairsUnique(t,e){let i=t.length;for(let s=0;s!==i;s++)ts[s]=t[s],to[s]=e[s];t.length=0,e.length=0;for(let t=0;t!==i;t++){let e=ts[t].id,i=to[t].id,s=e<i?`${e},${i}`:`${i},${e}`;ti[s]=t,ti.keys.push(s)}for(let i=0;i!==ti.keys.length;i++){let i=ti.keys.pop(),s=ti[i];t.push(ts[s]),e.push(to[s]),delete ti[i]}}setWorld(t){}static boundingSphereCheck(t,e){let i=new v;t.position.vsub(e.position,i);let s=t.shapes[0],o=e.shapes[0];return Math.pow(s.boundingSphereRadius+o.boundingSphereRadius,2)>i.lengthSquared()}aabbQuery(t,e,i){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const te=new v;new v,new C,new v;const ti={keys:[]},ts=[],to=[];new v,new v,new v;class tn extends tt{constructor(){super()}collisionPairs(t,e,i){let s,o;let n=t.bodies,r=n.length;for(let t=0;t!==r;t++)for(let r=0;r!==t;r++)s=n[t],o=n[r],this.needBroadphaseCollision(s,o)&&this.intersectionTest(s,o,e,i)}aabbQuery(t,e,i){void 0===i&&(i=[]);for(let s=0;s<t.bodies.length;s++){let o=t.bodies[s];o.aabbNeedsUpdate&&o.updateAABB(),o.aabb.overlaps(e)&&i.push(o)}return i}}class tr{constructor(){this.rayFromWorld=new v,this.rayToWorld=new v,this.hitNormalWorld=new v,this.hitPointWorld=new v,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,i,s,o,n,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(i),this.hitPointWorld.copy(s),this.shape=o,this.body=n,this.distance=r}}const ta={CLOSEST:1,ANY:2,ALL:4};t=q.types.SPHERE,e=q.types.PLANE,i=q.types.BOX,s=q.types.CYLINDER,o=q.types.CONVEXPOLYHEDRON,n=q.types.HEIGHTFIELD,r=q.types.TRIMESH;class tl{get[t](){return this._intersectSphere}get[e](){return this._intersectPlane}get[i](){return this._intersectBox}get[s](){return this._intersectConvex}get[o](){return this._intersectConvex}get[n](){return this._intersectHeightfield}get[r](){return this._intersectTrimesh}constructor(t,e){void 0===t&&(t=new v),void 0===e&&(e=new v),this.from=t.clone(),this.to=e.clone(),this.direction=new v,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=tl.ANY,this.result=new tr,this.hasHit=!1,this.callback=t=>{}}intersectWorld(t,e){return this.mode=e.mode||tl.ANY,this.result=e.result||new tr,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===e.checkCollisionResponse||e.checkCollisionResponse,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(th),tc.length=0,t.broadphase.aabbQuery(t,th,tc),this.intersectBodies(tc),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());let i=this.checkCollisionResponse;if((!i||t.collisionResponse)&&(this.collisionFilterGroup&t.collisionFilterMask)!=0&&(t.collisionFilterGroup&this.collisionFilterMask)!=0)for(let e=0,s=t.shapes.length;e<s;e++){let s=t.shapes[e];if((!i||s.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[e],ty),t.quaternion.vmult(t.shapeOffsets[e],tp),tp.vadd(t.position,tp),this.intersectShape(s,ty,tp,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let e=0,i=t.length;!this.result.shouldStop&&e<i;e++)this.intersectBody(t[e])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,i,s){if(function(t,e,i){i.vsub(t,tR);let s=tR.dot(e);return e.scale(s,tL),tL.vadd(t,tL),i.distanceTo(tL)}(this.from,this.direction,i)>t.boundingSphereRadius)return;let o=this[t.type];o&&o.call(this,t,e,i,s,t)}_intersectBox(t,e,i,s,o){return this._intersectConvex(t.convexPolyhedronRepresentation,e,i,s,o)}_intersectPlane(t,e,i,s,o){let n=this.from,r=this.to,a=this.direction,l=new v(0,0,1);e.vmult(l,l);let h=new v;n.vsub(i,h);let c=h.dot(l);if(r.vsub(i,h),c*h.dot(l)>0||n.distanceTo(r)<c)return;let d=l.dot(a);if(Math.abs(d)<this.precision)return;let u=new v,p=new v,y=new v;n.vsub(i,u);let m=-l.dot(u)/d;a.scale(m,p),n.vadd(p,y),this.reportIntersection(l,y,o,s,-1)}getAABB(t){let{lowerBound:e,upperBound:i}=t,s=this.to,o=this.from;e.x=Math.min(s.x,o.x),e.y=Math.min(s.y,o.y),e.z=Math.min(s.z,o.z),i.x=Math.max(s.x,o.x),i.y=Math.max(s.y,o.y),i.z=Math.max(s.z,o.z)}_intersectHeightfield(t,e,i,s,o){let n,r,a,l;t.data,t.elementSize,tx.from.copy(this.from),tx.to.copy(this.to),B.pointToLocalFrame(i,e,tx.from,tx.from),B.pointToLocalFrame(i,e,tx.to,tx.to),tx.updateDirection(),n=r=0,a=l=t.data.length-1;let h=new g;tx.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,tE,!0),n=Math.max(n,tE[0]),r=Math.max(r,tE[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,tE,!0),a=Math.min(a,tE[0]+1),l=Math.min(l,tE[1]+1);for(let c=n;c<a;c++)for(let n=r;n<l;n++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(c,n,h),h.overlapsRay(tx)){if(t.getConvexTrianglePillar(c,n,!1),B.pointToWorldFrame(i,e,t.pillarOffset,tb),this._intersectConvex(t.pillarConvex,e,tb,s,o,tg),this.result.shouldStop)return;t.getConvexTrianglePillar(c,n,!0),B.pointToWorldFrame(i,e,t.pillarOffset,tb),this._intersectConvex(t.pillarConvex,e,tb,s,o,tg)}}}_intersectSphere(t,e,i,s,o){let n=this.from,r=this.to,a=t.radius,l=(r.x-n.x)**2+(r.y-n.y)**2+(r.z-n.z)**2,h=2*((r.x-n.x)*(n.x-i.x)+(r.y-n.y)*(n.y-i.y)+(r.z-n.z)*(n.z-i.z)),c=h**2-4*l*((n.x-i.x)**2+(n.y-i.y)**2+(n.z-i.z)**2-a**2);if(!(c<0)){if(0===c)n.lerp(r,c,tz),tz.vsub(i,tC),tC.normalize(),this.reportIntersection(tC,tz,o,s,-1);else{let t=(-h-Math.sqrt(c))/(2*l),e=(-h+Math.sqrt(c))/(2*l);if(t>=0&&t<=1&&(n.lerp(r,t,tz),tz.vsub(i,tC),tC.normalize(),this.reportIntersection(tC,tz,o,s,-1)),this.result.shouldStop)return;e>=0&&e<=1&&(n.lerp(r,e,tz),tz.vsub(i,tC),tC.normalize(),this.reportIntersection(tC,tz,o,s,-1))}}}_intersectConvex(t,e,i,s,o,n){let r=n&&n.faceList||null,a=t.faces,l=t.vertices,h=t.faceNormals,c=this.direction,d=this.from,u=this.to,p=d.distanceTo(u),y=r?r.length:a.length,v=this.result;for(let t=0;!v.shouldStop&&t<y;t++){let n=r?r[t]:t,u=a[n],y=h[n];tM.copy(l[u[0]]),e.vmult(tM,tM),tM.vadd(i,tM),tM.vsub(d,tM),e.vmult(y,tS);let m=c.dot(tS);if(Math.abs(m)<this.precision)continue;let w=tS.dot(tM)/m;if(!(w<0)){c.scale(w,tv),tv.vadd(d,tv),tm.copy(l[u[0]]),e.vmult(tm,tm),i.vadd(tm,tm);for(let t=1;!v.shouldStop&&t<u.length-1;t++){tw.copy(l[u[t]]),tf.copy(l[u[t+1]]),e.vmult(tw,tw),e.vmult(tf,tf),i.vadd(tw,tw),i.vadd(tf,tf);let r=tv.distanceTo(d);(tl.pointInTriangle(tv,tm,tw,tf)||tl.pointInTriangle(tv,tw,tm,tf))&&!(r>p)&&this.reportIntersection(tS,tv,o,s,n)}}}}_intersectTrimesh(t,e,i,s,o,n){let r=t.indices;t.vertices;let a=this.from,l=this.to,h=this.direction;tN.position.copy(i),tN.quaternion.copy(e),B.vectorToLocalFrame(i,e,h,tB),B.pointToLocalFrame(i,e,a,tP),B.pointToLocalFrame(i,e,l,tA),tA.x*=t.scale.x,tA.y*=t.scale.y,tA.z*=t.scale.z,tP.x*=t.scale.x,tP.y*=t.scale.y,tP.z*=t.scale.z,tA.vsub(tP,tB),tB.normalize();let c=tP.distanceSquared(tA);t.tree.rayQuery(this,tN,tT);for(let n=0,a=tT.length;!this.result.shouldStop&&n!==a;n++){let a=tT[n];t.getNormal(a,tq),t.getVertex(r[3*a],tm),tm.vsub(tP,tM);let l=tB.dot(tq),h=tq.dot(tM)/l;if(h<0)continue;tB.scale(h,tv),tv.vadd(tP,tv),t.getVertex(r[3*a+1],tw),t.getVertex(r[3*a+2],tf);let d=tv.distanceSquared(tP);(tl.pointInTriangle(tv,tw,tm,tf)||tl.pointInTriangle(tv,tm,tw,tf))&&!(d>c)&&(B.vectorToWorldFrame(e,tq,tF),B.pointToWorldFrame(i,e,tv,tI),this.reportIntersection(tF,tI,o,s,a))}tT.length=0}reportIntersection(t,e,i,s,o){let n=this.from,r=this.to,a=n.distanceTo(e),l=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==o?o:-1,this.mode){case tl.ALL:this.hasHit=!0,l.set(n,r,t,e,i,s,a),l.hasHit=!0,this.callback(l);break;case tl.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(n,r,t,e,i,s,a));break;case tl.ANY:this.hasHit=!0,l.hasHit=!0,l.set(n,r,t,e,i,s,a),l.shouldStop=!0}}static pointInTriangle(t,e,i,s){let o,n;s.vsub(e,tR),i.vsub(e,td),t.vsub(e,tu);let r=tR.dot(tR),a=tR.dot(td),l=tR.dot(tu),h=td.dot(td),c=td.dot(tu);return(o=h*l-a*c)>=0&&(n=r*c-a*l)>=0&&o+n<r*h-a*a}}tl.CLOSEST=ta.CLOSEST,tl.ANY=ta.ANY,tl.ALL=ta.ALL;const th=new g,tc=[],td=new v,tu=new v,tp=new v,ty=new C,tv=new v,tm=new v,tw=new v,tf=new v;new v,new tr;const tg={faceList:[0]},tb=new v,tx=new tl,tE=[],tz=new v,tC=new v,tS=new v;new v,new v;const tM=new v,tq=new v,tB=new v,tP=new v,tA=new v,tF=new v,tI=new v;new g;const tT=[],tN=new B,tR=new v,tL=new v;class tj{static defaults(t,e){for(let i in void 0===t&&(t={}),e)i in t||(t[i]=e[i]);return t}}class tk{constructor(t,e,i){void 0===i&&(i={}),i=tj.defaults(i,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=t,this.bodyB=e,this.id=tk.idCounter++,this.collideConnected=i.collideConnected,i.wakeUpBodies&&(t&&t.wakeUp(),e&&e.wakeUp())}update(){throw Error("method update() not implmemented in this Constraint subclass!")}enable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!0}disable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!1}}tk.idCounter=0;class tW{constructor(){this.spatial=new v,this.rotational=new v}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class tO{constructor(t,e,i,s){void 0===i&&(i=-1e6),void 0===s&&(s=1e6),this.id=tO.idCounter++,this.minForce=i,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new tW,this.jacobianElementB=new tW,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,i){this.a=4/(i*(1+4*e)),this.b=4*e/(1+4*e),this.eps=4/(i*i*t*(1+4*e))}computeB(t,e,i){let s=this.computeGW();return-this.computeGq()*t-s*e-this.computeGiMf()*i}computeGq(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.position,n=s.position;return t.spatial.dot(o)+e.spatial.dot(n)}computeGW(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.velocity,n=s.velocity,r=i.angularVelocity,a=s.angularVelocity;return t.multiplyVectors(o,r)+e.multiplyVectors(n,a)}computeGWlambda(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.vlambda,n=s.vlambda,r=i.wlambda,a=s.wlambda;return t.multiplyVectors(o,r)+e.multiplyVectors(n,a)}computeGiMf(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.force,n=i.torque,r=s.force,a=s.torque,l=i.invMassSolve,h=s.invMassSolve;return o.scale(l,tV),r.scale(h,tD),i.invInertiaWorldSolve.vmult(n,tH),s.invInertiaWorldSolve.vmult(a,tG),t.multiplyVectors(tV,tH)+e.multiplyVectors(tD,tG)}computeGiMGt(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,o=i.invMassSolve,n=s.invMassSolve,r=i.invInertiaWorldSolve,a=s.invInertiaWorldSolve,l=o+n;return r.vmult(t.rotational,tY),l+=tY.dot(t.rotational),a.vmult(e.rotational,tY),l+=tY.dot(e.rotational)}addToWlambda(t){let e=this.jacobianElementA,i=this.jacobianElementB,s=this.bi,o=this.bj;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),o.vlambda.addScaledVector(o.invMassSolve*t,i.spatial,o.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,tX),s.wlambda.addScaledVector(t,tX,s.wlambda),o.invInertiaWorldSolve.vmult(i.rotational,tX),o.wlambda.addScaledVector(t,tX,o.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}tO.idCounter=0;const tV=new v,tD=new v,tH=new v,tG=new v,tY=new v,tX=new v;class tU extends tO{constructor(t,e,i){void 0===i&&(i=1e6),super(t,e,0,i),this.restitution=0,this.ri=new v,this.rj=new v,this.ni=new v}computeB(t){let e=this.a,i=this.b,s=this.bi,o=this.bj,n=this.ri,r=this.rj,a=s.velocity,l=s.angularVelocity;s.force,s.torque;let h=o.velocity,c=o.angularVelocity;o.force,o.torque;let d=this.jacobianElementA,u=this.jacobianElementB,p=this.ni;n.cross(p,t_),r.cross(p,tZ),p.negate(d.spatial),t_.negate(d.rotational),u.spatial.copy(p),u.rotational.copy(tZ),tK.copy(o.position),tK.vadd(r,tK),tK.vsub(s.position,tK),tK.vsub(n,tK);let y=p.dot(tK),v=this.restitution+1;return-y*e-(v*h.dot(p)-v*a.dot(p)+c.dot(tZ)-l.dot(t_))*i-t*this.computeGiMf()}getImpactVelocityAlongNormal(){return this.bi.position.vadd(this.ri,tJ),this.bj.position.vadd(this.rj,t0),this.bi.getVelocityAtWorldPoint(tJ,t$),this.bj.getVelocityAtWorldPoint(t0,tQ),t$.vsub(tQ,t1),this.ni.dot(t1)}}const t_=new v,tZ=new v,tK=new v,t$=new v,tQ=new v,tJ=new v,t0=new v,t1=new v;new v,new v,new v,new v,new v,new v,new v,new v,new v,new v;class t2 extends tO{constructor(t,e,i){super(t,e,-i,i),this.ri=new v,this.rj=new v,this.t=new v}computeB(t){this.a;let e=this.b;this.bi,this.bj;let i=this.ri,s=this.rj,o=this.t;i.cross(o,t5),s.cross(o,t3);let n=this.jacobianElementA,r=this.jacobianElementB;return o.negate(n.spatial),t5.negate(n.rotational),r.spatial.copy(o),r.rotational.copy(t3),-this.computeGW()*e-t*this.computeGiMf()}}const t5=new v,t3=new v;class t6{constructor(t,e,i){i=tj.defaults(i,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=t6.idCounter++,this.materials=[t,e],this.friction=i.friction,this.restitution=i.restitution,this.contactEquationStiffness=i.contactEquationStiffness,this.contactEquationRelaxation=i.contactEquationRelaxation,this.frictionEquationStiffness=i.frictionEquationStiffness,this.frictionEquationRelaxation=i.frictionEquationRelaxation}}t6.idCounter=0;class t4{constructor(t){void 0===t&&(t={});let e="";"string"==typeof t&&(e=t,t={}),this.name=e,this.id=t4.idCounter++,this.friction=void 0!==t.friction?t.friction:-1,this.restitution=void 0!==t.restitution?t.restitution:-1}}t4.idCounter=0,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new tl,new v,new v,new v,new v(1,0,0),new v(0,1,0),new v(0,0,1),new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new v,new g,new v,new g,new v,new v,new v,new v,new v,new v,new v,new g,new v,new B,new g;class t7{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){!t.enabled||t.bi.isTrigger||t.bj.isTrigger||this.equations.push(t)}removeEquation(t){let e=this.equations,i=e.indexOf(t);-1!==i&&e.splice(i,1)}removeAllEquations(){this.equations.length=0}}class t8 extends t7{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let i,s,o,n,r,a=0,l=this.iterations,h=this.tolerance*this.tolerance,c=this.equations,d=c.length,u=e.bodies,p=u.length;if(0!==d)for(let t=0;t!==p;t++)u[t].updateSolveMassProperties();et.length=d,ee.length=d,t9.length=d;for(let e=0;e!==d;e++){let i=c[e];t9[e]=0,ee[e]=i.computeB(t),et[e]=1/i.computeC()}if(0!==d){for(let t=0;t!==p;t++){let e=u[t],i=e.vlambda,s=e.wlambda;i.set(0,0,0),s.set(0,0,0)}for(a=0;a!==l;a++){n=0;for(let t=0;t!==d;t++){let e=c[t];i=ee[t],s=et[t],r=t9[t],o=s*(i-e.computeGWlambda()-e.eps*r),r+o<e.minForce?o=e.minForce-r:r+o>e.maxForce&&(o=e.maxForce-r),t9[t]+=o,n+=o>0?o:-o,e.addToWlambda(o)}if(n*n<h)break}for(let t=0;t!==p;t++){let e=u[t],i=e.velocity,s=e.angularVelocity;e.vlambda.vmul(e.linearFactor,e.vlambda),i.vadd(e.vlambda,i),e.wlambda.vmul(e.angularFactor,e.wlambda),s.vadd(e.wlambda,s)}let e=c.length,y=1/t;for(;e--;)c[e].multiplier=t9[e]*y}return a}}const t9=[],et=[],ee=[];O.STATIC;class ei{constructor(){this.objects=[],this.type=Object}release(){let t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){let e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class es extends ei{constructor(){super(...arguments),this.type=v}constructObject(){return new v}}const eo={sphereSphere:q.types.SPHERE,spherePlane:q.types.SPHERE|q.types.PLANE,boxBox:q.types.BOX|q.types.BOX,sphereBox:q.types.SPHERE|q.types.BOX,planeBox:q.types.PLANE|q.types.BOX,convexConvex:q.types.CONVEXPOLYHEDRON,sphereConvex:q.types.SPHERE|q.types.CONVEXPOLYHEDRON,planeConvex:q.types.PLANE|q.types.CONVEXPOLYHEDRON,boxConvex:q.types.BOX|q.types.CONVEXPOLYHEDRON,sphereHeightfield:q.types.SPHERE|q.types.HEIGHTFIELD,boxHeightfield:q.types.BOX|q.types.HEIGHTFIELD,convexHeightfield:q.types.CONVEXPOLYHEDRON|q.types.HEIGHTFIELD,sphereParticle:q.types.PARTICLE|q.types.SPHERE,planeParticle:q.types.PLANE|q.types.PARTICLE,boxParticle:q.types.BOX|q.types.PARTICLE,convexParticle:q.types.PARTICLE|q.types.CONVEXPOLYHEDRON,cylinderCylinder:q.types.CYLINDER,sphereCylinder:q.types.SPHERE|q.types.CYLINDER,planeCylinder:q.types.PLANE|q.types.CYLINDER,boxCylinder:q.types.BOX|q.types.CYLINDER,convexCylinder:q.types.CONVEXPOLYHEDRON|q.types.CYLINDER,heightfieldCylinder:q.types.HEIGHTFIELD|q.types.CYLINDER,particleCylinder:q.types.PARTICLE|q.types.CYLINDER,sphereTrimesh:q.types.SPHERE|q.types.TRIMESH,planeTrimesh:q.types.PLANE|q.types.TRIMESH};class en{get[eo.sphereSphere](){return this.sphereSphere}get[eo.spherePlane](){return this.spherePlane}get[eo.boxBox](){return this.boxBox}get[eo.sphereBox](){return this.sphereBox}get[eo.planeBox](){return this.planeBox}get[eo.convexConvex](){return this.convexConvex}get[eo.sphereConvex](){return this.sphereConvex}get[eo.planeConvex](){return this.planeConvex}get[eo.boxConvex](){return this.boxConvex}get[eo.sphereHeightfield](){return this.sphereHeightfield}get[eo.boxHeightfield](){return this.boxHeightfield}get[eo.convexHeightfield](){return this.convexHeightfield}get[eo.sphereParticle](){return this.sphereParticle}get[eo.planeParticle](){return this.planeParticle}get[eo.boxParticle](){return this.boxParticle}get[eo.convexParticle](){return this.convexParticle}get[eo.cylinderCylinder](){return this.convexConvex}get[eo.sphereCylinder](){return this.sphereConvex}get[eo.planeCylinder](){return this.planeConvex}get[eo.boxCylinder](){return this.boxConvex}get[eo.convexCylinder](){return this.convexConvex}get[eo.heightfieldCylinder](){return this.heightfieldCylinder}get[eo.particleCylinder](){return this.particleCylinder}get[eo.sphereTrimesh](){return this.sphereTrimesh}get[eo.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new es,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,i,s,o,n){let r;this.contactPointPool.length?((r=this.contactPointPool.pop()).bi=t,r.bj=e):r=new tU(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&i.collisionResponse&&s.collisionResponse;let a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);let l=i.material||t.material,h=s.material||e.material;return l&&h&&l.restitution>=0&&h.restitution>=0&&(r.restitution=l.restitution*h.restitution),r.si=o||i,r.sj=n||s,r}createFrictionEquationsFromContact(t,e){let i=t.bi,s=t.bj,o=t.si,n=t.sj,r=this.world,a=this.currentContactMaterial,l=a.friction,h=o.material||i.material,c=n.material||s.material;if(h&&c&&h.friction>=0&&c.friction>=0&&(l=h.friction*c.friction),l>0){let o=l*(r.frictionGravity||r.gravity).length(),n=i.invMass+s.invMass;n>0&&(n=1/n);let h=this.frictionEquationPool,c=h.length?h.pop():new t2(i,s,o*n),d=h.length?h.pop():new t2(i,s,o*n);return c.bi=d.bi=i,c.bj=d.bj=s,c.minForce=d.minForce=-o*n,c.maxForce=d.maxForce=o*n,c.ri.copy(t.ri),c.rj.copy(t.rj),d.ri.copy(t.ri),d.rj.copy(t.rj),t.ni.tangents(c.t,d.t),c.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),d.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),c.enabled=d.enabled=t.enabled,e.push(c,d),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||1===t)return;let i=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];er.setZero(),ea.setZero(),el.setZero();let o=e.bi;e.bj;for(let i=0;i!==t;i++)(e=this.result[this.result.length-1-i]).bi!==o?(er.vadd(e.ni,er),ea.vadd(e.ri,ea),el.vadd(e.rj,el)):(er.vsub(e.ni,er),ea.vadd(e.rj,ea),el.vadd(e.ri,el));let n=1/t;ea.scale(n,i.ri),el.scale(n,i.rj),s.ri.copy(i.ri),s.rj.copy(i.rj),er.normalize(),er.tangents(i.t,s.t)}getContacts(t,e,i,s,o,n,r){this.contactPointPool=o,this.frictionEquationPool=r,this.result=s,this.frictionResult=n;for(let s=0,o=t.length;s!==o;s++){let o=t[s],n=e[s],r=null;o.material&&n.material&&(r=i.getContactMaterial(o.material,n.material)||null);let a=o.type&O.KINEMATIC&&n.type&O.STATIC||o.type&O.STATIC&&n.type&O.KINEMATIC||o.type&O.KINEMATIC&&n.type&O.KINEMATIC;for(let t=0;t<o.shapes.length;t++){o.quaternion.mult(o.shapeOrientations[t],ed),o.quaternion.vmult(o.shapeOffsets[t],eh),eh.vadd(o.position,eh);let e=o.shapes[t];for(let t=0;t<n.shapes.length;t++){n.quaternion.mult(n.shapeOrientations[t],eu),n.quaternion.vmult(n.shapeOffsets[t],ec),ec.vadd(n.position,ec);let s=n.shapes[t];if(!(e.collisionFilterMask&s.collisionFilterGroup&&s.collisionFilterMask&e.collisionFilterGroup)||eh.distanceTo(ec)>e.boundingSphereRadius+s.boundingSphereRadius)continue;let l=null;e.material&&s.material&&(l=i.getContactMaterial(e.material,s.material)||null),this.currentContactMaterial=l||r||i.defaultContactMaterial;let h=this[e.type|s.type];h&&(e.type<s.type?h.call(this,e,s,eh,ec,ed,eu,o,n,e,s,a):h.call(this,s,e,ec,eh,eu,ed,n,o,e,s,a))&&a&&(i.shapeOverlapKeeper.set(e.id,s.id),i.bodyOverlapKeeper.set(o.id,n.id))}}}}sphereSphere(t,e,i,s,o,n,r,a,l,h,c){if(c)return i.distanceSquared(s)<(t.radius+e.radius)**2;let d=this.createContactEquation(r,a,t,e,l,h);s.vsub(i,d.ni),d.ni.normalize(),d.ri.copy(d.ni),d.rj.copy(d.ni),d.ri.scale(t.radius,d.ri),d.rj.scale(-e.radius,d.rj),d.ri.vadd(i,d.ri),d.ri.vsub(r.position,d.ri),d.rj.vadd(s,d.rj),d.rj.vsub(a.position,d.rj),this.result.push(d),this.createFrictionEquationsFromContact(d,this.frictionResult)}spherePlane(t,e,i,s,o,n,r,a,l,h,c){let d=this.createContactEquation(r,a,t,e,l,h);if(d.ni.set(0,0,1),n.vmult(d.ni,d.ni),d.ni.negate(d.ni),d.ni.normalize(),d.ni.scale(t.radius,d.ri),i.vsub(s,eF),d.ni.scale(d.ni.dot(eF),eI),eF.vsub(eI,d.rj),-eF.dot(d.ni)<=t.radius){if(c)return!0;let t=d.ri,e=d.rj;t.vadd(i,t),t.vsub(r.position,t),e.vadd(s,e),e.vsub(a.position,e),this.result.push(d),this.createFrictionEquationsFromContact(d,this.frictionResult)}}boxBox(t,e,i,s,o,n,r,a,l,h,c){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,i,s,o,n,r,a,t,e,c)}sphereBox(t,e,i,s,o,n,r,a,l,h,c){let d=this.v3pool;i.vsub(s,eL),e.getSideNormals(eO,n);let u=t.radius,p=!1,y=null,v=0,m=0,w=0,f=null;for(let t=0,e=eO.length;t!==e&&!1===p;t++){ej.copy(eO[t]);let e=ej.length();ej.normalize();let i=eL.dot(ej);if(i<e+u&&i>0){ek.copy(eO[(t+1)%3]),eW.copy(eO[(t+2)%3]);let s=ek.length(),o=eW.length();ek.normalize(),eW.normalize();let n=eL.dot(ek),r=eL.dot(eW);if(n<s&&n>-s&&r<o&&r>-o){let t=Math.abs(i-e-u);if((null===f||t<f)&&(f=t,m=n,w=r,y=e,eD.copy(ej),eH.copy(ek),eG.copy(eW),v++,c))return!0}}}if(v){p=!0;let o=this.createContactEquation(r,a,t,e,l,h);eD.scale(-u,o.ri),o.ni.copy(eD),o.ni.negate(o.ni),eD.scale(y,eD),eH.scale(m,eH),eD.vadd(eH,eD),eG.scale(w,eG),eD.vadd(eG,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(a.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}let g=d.get();for(let o=0;2!==o&&!p;o++)for(let n=0;2!==n&&!p;n++)for(let d=0;2!==d&&!p;d++)if(g.set(0,0,0),o?g.vadd(eO[0],g):g.vsub(eO[0],g),n?g.vadd(eO[1],g):g.vsub(eO[1],g),d?g.vadd(eO[2],g):g.vsub(eO[2],g),s.vadd(g,eV),eV.vsub(i,eV),eV.lengthSquared()<u*u){if(c)return!0;p=!0;let o=this.createContactEquation(r,a,t,e,l,h);o.ri.copy(eV),o.ri.normalize(),o.ni.copy(o.ri),o.ri.scale(u,o.ri),o.rj.copy(g),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(a.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}d.release(g),g=null;let b=d.get(),x=d.get(),E=d.get(),z=d.get(),C=d.get(),S=eO.length;for(let o=0;o!==S&&!p;o++)for(let n=0;n!==S&&!p;n++)if(o%3!=n%3){eO[n].cross(eO[o],b),b.normalize(),eO[o].vadd(eO[n],x),E.copy(i),E.vsub(x,E),E.vsub(s,E);let d=E.dot(b);b.scale(d,z);let y=0;for(;y===o%3||y===n%3;)y++;C.copy(i),C.vsub(z,C),C.vsub(x,C),C.vsub(s,C);let v=Math.abs(d),m=C.length();if(v<eO[y].length()&&m<u){if(c)return!0;p=!0;let o=this.createContactEquation(r,a,t,e,l,h);x.vadd(z,o.rj),o.rj.copy(o.rj),C.negate(o.ni),o.ni.normalize(),o.ri.copy(o.rj),o.ri.vadd(s,o.ri),o.ri.vsub(i,o.ri),o.ri.normalize(),o.ri.scale(u,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(a.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}d.release(b,x,E,z,C)}planeBox(t,e,i,s,o,n,r,a,l,h,c){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,i,s,o,n,r,a,t,e,c)}convexConvex(t,e,i,s,o,n,r,a,l,h,c,d,u){if(!(i.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,i,o,s,n,e6,d,u)){let d=[];t.clipAgainstHull(i,o,e,s,n,e6,-100,100,d);let u=0;for(let o=0;o!==d.length;o++){if(c)return!0;let n=this.createContactEquation(r,a,t,e,l,h),p=n.ri,y=n.rj;e6.negate(n.ni),d[o].normal.negate(e4),e4.scale(d[o].depth,e4),d[o].point.vadd(e4,p),y.copy(d[o].point),p.vsub(i,p),y.vsub(s,y),p.vadd(i,p),p.vsub(r.position,p),y.vadd(s,y),y.vsub(a.position,y),this.result.push(n),u++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}this.enableFrictionReduction&&u&&this.createFrictionFromAverage(u)}}sphereConvex(t,e,i,s,o,n,r,a,l,h,c){let d=this.v3pool;i.vsub(s,eY);let u=e.faceNormals,p=e.faces,y=e.vertices,v=t.radius,m=!1;for(let o=0;o!==y.length;o++){let d=y[o];if(n.vmult(d,eZ),s.vadd(eZ,eZ),eZ.vsub(i,e_),e_.lengthSquared()<v*v){if(c)return!0;m=!0;let o=this.createContactEquation(r,a,t,e,l,h);o.ri.copy(e_),o.ri.normalize(),o.ni.copy(o.ri),o.ri.scale(v,o.ri),eZ.vsub(s,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(a.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);return}}for(let o=0,w=p.length;o!==w&&!1===m;o++){let w=u[o],f=p[o];n.vmult(w,eK),n.vmult(y[f[0]],e$),e$.vadd(s,e$),eK.scale(-v,eQ),i.vadd(eQ,eQ),eQ.vsub(e$,eJ);let g=eJ.dot(eK);if(i.vsub(e$,e0),g<0&&e0.dot(eK)>0){let o=[];for(let t=0,e=f.length;t!==e;t++){let e=d.get();n.vmult(y[f[t]],e),s.vadd(e,e),o.push(e)}if(function(t,e,i){let s=null,o=t.length;for(let n=0;n!==o;n++){let r=t[n];t[(n+1)%o].vsub(r,eT),eT.cross(e,eN),i.vsub(r,eR);let a=eN.dot(eR);if(null!==s&&(!(a>0)||!0!==s)&&(!(a<=0)||!1!==s))return!1;null===s&&(s=a>0)}return!0}(o,eK,i)){if(c)return!0;m=!0;let n=this.createContactEquation(r,a,t,e,l,h);eK.scale(-v,n.ri),eK.negate(n.ni);let u=d.get();eK.scale(-g,u);let p=d.get();eK.scale(-v,p),i.vsub(s,n.rj),n.rj.vadd(p,n.rj),n.rj.vadd(u,n.rj),n.rj.vadd(s,n.rj),n.rj.vsub(a.position,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),d.release(u),d.release(p),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let t=0,e=o.length;t!==e;t++)d.release(o[t]);return}for(let u=0;u!==f.length;u++){let p=d.get(),m=d.get();n.vmult(y[f[(u+1)%f.length]],p),n.vmult(y[f[(u+2)%f.length]],m),s.vadd(p,p),s.vadd(m,m),m.vsub(p,eX),eX.unit(eU);let w=d.get(),g=d.get();i.vsub(p,g);let b=g.dot(eU);eU.scale(b,w),w.vadd(p,w);let x=d.get();if(w.vsub(i,x),b>0&&b*b<eX.lengthSquared()&&x.lengthSquared()<v*v){if(c)return!0;let n=this.createContactEquation(r,a,t,e,l,h);w.vsub(s,n.rj),w.vsub(i,n.ni),n.ni.normalize(),n.ni.scale(v,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(a.position,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let t=0,e=o.length;t!==e;t++)d.release(o[t]);d.release(p),d.release(m),d.release(w),d.release(x),d.release(g);return}d.release(p),d.release(m),d.release(w),d.release(x),d.release(g)}for(let t=0,e=o.length;t!==e;t++)d.release(o[t])}}}planeConvex(t,e,i,s,o,n,r,a,l,h,c){e2.set(0,0,1),o.vmult(e2,e2);let d=0;for(let o=0;o!==e.vertices.length;o++)if(e1.copy(e.vertices[o]),n.vmult(e1,e1),s.vadd(e1,e1),e1.vsub(i,e5),0>=e2.dot(e5)){if(c)return!0;let o=this.createContactEquation(r,a,t,e,l,h);e2.scale(e2.dot(e5),e3),e1.vsub(e3,e3),e3.vsub(i,o.ri),o.ni.copy(e2),e1.vsub(s,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(a.position,o.rj),this.result.push(o),d++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(o,this.frictionResult)}this.enableFrictionReduction&&d&&this.createFrictionFromAverage(d)}boxConvex(t,e,i,s,o,n,r,a,l,h,c){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,i,s,o,n,r,a,t,e,c)}sphereHeightfield(t,e,i,s,o,n,r,a,l,h,c){let d=e.data,u=t.radius,p=e.elementSize;B.pointToLocalFrame(s,n,i,ic);let y=Math.floor((ic.x-u)/p)-1,v=Math.ceil((ic.x+u)/p)+1,m=Math.floor((ic.y-u)/p)-1,w=Math.ceil((ic.y+u)/p)+1;if(v<0||w<0||y>d.length||m>d[0].length)return;y<0&&(y=0),v<0&&(v=0),m<0&&(m=0),w<0&&(w=0),y>=d.length&&(y=d.length-1),v>=d.length&&(v=d.length-1),w>=d[0].length&&(w=d[0].length-1),m>=d[0].length&&(m=d[0].length-1);let f=[];e.getRectMinMax(y,m,v,w,f);let g=f[0],b=f[1];if(ic.z-u>b||ic.z+u<g)return;let x=this.result;for(let l=y;l<v;l++)for(let h=m;h<w;h++){let d=x.length,u=!1;if(e.getConvexTrianglePillar(l,h,!1),B.pointToWorldFrame(s,n,e.pillarOffset,id),i.distanceTo(id)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(u=this.sphereConvex(t,e.pillarConvex,i,id,o,n,r,a,t,e,c)),c&&u||(e.getConvexTrianglePillar(l,h,!0),B.pointToWorldFrame(s,n,e.pillarOffset,id),i.distanceTo(id)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(u=this.sphereConvex(t,e.pillarConvex,i,id,o,n,r,a,t,e,c)),c&&u))return!0;if(x.length-d>2)return}}boxHeightfield(t,e,i,s,o,n,r,a,l,h,c){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,i,s,o,n,r,a,t,e,c)}convexHeightfield(t,e,i,s,o,n,r,a,l,h,c){let d=e.data,u=e.elementSize,p=t.boundingSphereRadius;B.pointToLocalFrame(s,n,i,ia);let y=Math.floor((ia.x-p)/u)-1,v=Math.ceil((ia.x+p)/u)+1,m=Math.floor((ia.y-p)/u)-1,w=Math.ceil((ia.y+p)/u)+1;if(v<0||w<0||y>d.length||m>d[0].length)return;y<0&&(y=0),v<0&&(v=0),m<0&&(m=0),w<0&&(w=0),y>=d.length&&(y=d.length-1),v>=d.length&&(v=d.length-1),w>=d[0].length&&(w=d[0].length-1),m>=d[0].length&&(m=d[0].length-1);let f=[];e.getRectMinMax(y,m,v,w,f);let g=f[0],b=f[1];if(!(ia.z-p>b)&&!(ia.z+p<g))for(let l=y;l<v;l++)for(let h=m;h<w;h++){let d=!1;if(e.getConvexTrianglePillar(l,h,!1),B.pointToWorldFrame(s,n,e.pillarOffset,il),i.distanceTo(il)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(d=this.convexConvex(t,e.pillarConvex,i,il,o,n,r,a,null,null,c,ih,null)),c&&d||(e.getConvexTrianglePillar(l,h,!0),B.pointToWorldFrame(s,n,e.pillarOffset,il),i.distanceTo(il)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(d=this.convexConvex(t,e.pillarConvex,i,il,o,n,r,a,null,null,c,ih,null)),c&&d))return!0}}sphereParticle(t,e,i,s,o,n,r,a,l,h,c){if(it.set(0,0,1),s.vsub(i,it),it.lengthSquared()<=t.radius*t.radius){if(c)return!0;let i=this.createContactEquation(a,r,e,t,l,h);it.normalize(),i.rj.copy(it),i.rj.scale(t.radius,i.rj),i.ni.copy(it),i.ni.negate(i.ni),i.ri.set(0,0,0),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}planeParticle(t,e,i,s,o,n,r,a,l,h,c){if(e7.set(0,0,1),r.quaternion.vmult(e7,e7),s.vsub(r.position,e8),0>=e7.dot(e8)){if(c)return!0;let i=this.createContactEquation(a,r,e,t,l,h);i.ni.copy(e7),i.ni.negate(i.ni),i.ri.set(0,0,0),e7.scale(e7.dot(s),e9),s.vsub(e9,e9),i.rj.copy(e9),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}boxParticle(t,e,i,s,o,n,r,a,l,h,c){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,i,s,o,n,r,a,t,e,c)}convexParticle(t,e,i,s,o,n,r,a,l,h,c){let d=-1,u=null;if(ii.copy(s),ii.vsub(i,ii),o.conjugate(ie),ie.vmult(ii,ii),t.pointIsInside(ii)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(i,o),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(o);for(let e=0,i=t.faces.length;e!==i;e++){let i=[t.worldVertices[t.faces[e][0]]],o=t.worldFaceNormals[e];s.vsub(i[0],io);let n=-o.dot(io);if(null===u||Math.abs(n)<Math.abs(u)){if(c)return!0;u=n,d=e,is.copy(o)}}if(-1!==d){let o=this.createContactEquation(a,r,e,t,l,h);is.scale(u,ir),ir.vadd(s,ir),ir.vsub(i,ir),o.rj.copy(ir),is.negate(o.ni),o.ri.set(0,0,0);let n=o.ri,c=o.rj;n.vadd(s,n),n.vsub(a.position,n),c.vadd(i,c),c.vsub(r.position,c),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,i,s,o,n,r,a,l,h,c){return this.convexHeightfield(e,t,s,i,n,o,a,r,l,h,c)}particleCylinder(t,e,i,s,o,n,r,a,l,h,c){return this.convexParticle(e,t,s,i,n,o,a,r,l,h,c)}sphereTrimesh(t,e,i,s,o,n,r,a,l,h,c){B.pointToLocalFrame(s,n,i,eC);let d=t.radius;eP.lowerBound.set(eC.x-d,eC.y-d,eC.z-d),eP.upperBound.set(eC.x+d,eC.y+d,eC.z+d),e.getTrianglesInAABB(eP,eA);let u=t.radius*t.radius;for(let o=0;o<eA.length;o++)for(let d=0;d<3;d++)if(e.getVertex(e.indices[3*eA[o]+d],ef),ef.vsub(eC,ew),ew.lengthSquared()<=u){if(eg.copy(ef),B.pointToWorldFrame(s,n,eg,ef),ef.vsub(i,ew),c)return!0;let o=this.createContactEquation(r,a,t,e,l,h);o.ni.copy(ew),o.ni.normalize(),o.ri.copy(o.ni),o.ri.scale(t.radius,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),o.rj.copy(ef),o.rj.vsub(a.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}for(let o=0;o<eA.length;o++)for(let d=0;d<3;d++){e.getVertex(e.indices[3*eA[o]+d],eb),e.getVertex(e.indices[3*eA[o]+(d+1)%3],ex),ex.vsub(eb,eE),eC.vsub(ex,eS);let u=eS.dot(eE);eC.vsub(eb,eS);let p=eS.dot(eE);if(p>0&&u<0&&(eC.vsub(eb,eS),ez.copy(eE),ez.normalize(),p=eS.dot(ez),ez.scale(p,eS),eS.vadd(eb,eS),eS.distanceTo(eC)<t.radius)){if(c)return!0;let o=this.createContactEquation(r,a,t,e,l,h);eS.vsub(eC,o.ni),o.ni.normalize(),o.ni.scale(t.radius,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),B.pointToWorldFrame(s,n,eS,eS),eS.vsub(a.position,o.rj),B.vectorToWorldFrame(n,o.ni,o.ni),B.vectorToWorldFrame(n,o.ri,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}for(let o=0,d=eA.length;o!==d;o++){e.getTriangleVertices(eA[o],eM,eq,eB),e.getNormal(eA[o],em),eC.vsub(eM,eS);let d=eS.dot(em);if(em.scale(d,eS),eC.vsub(eS,eS),d=eS.distanceTo(eC),tl.pointInTriangle(eS,eM,eq,eB)&&d<t.radius){if(c)return!0;let o=this.createContactEquation(r,a,t,e,l,h);eS.vsub(eC,o.ni),o.ni.normalize(),o.ni.scale(t.radius,o.ri),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),B.pointToWorldFrame(s,n,eS,eS),eS.vsub(a.position,o.rj),B.vectorToWorldFrame(n,o.ni,o.ni),B.vectorToWorldFrame(n,o.ri,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}eA.length=0}planeTrimesh(t,e,i,s,o,n,r,a,l,h,c){let d=new v;ep.set(0,0,1),o.vmult(ep,ep);for(let o=0;o<e.vertices.length/3;o++){e.getVertex(o,d);let u=new v;if(u.copy(d),B.pointToWorldFrame(s,n,u,d),d.vsub(i,ey),0>=ep.dot(ey)){if(c)return!0;let i=this.createContactEquation(r,a,t,e,l,h);i.ni.copy(ep),ep.scale(ey.dot(ep),ev),d.vsub(ev,ev),i.ri.copy(ev),i.ri.vsub(r.position,i.ri),i.rj.copy(d),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}}}const er=new v,ea=new v,el=new v,eh=new v,ec=new v,ed=new C,eu=new C,ep=new v,ey=new v,ev=new v,em=new v,ew=new v;new v;const ef=new v,eg=new v,eb=new v,ex=new v,eE=new v,ez=new v,eC=new v,eS=new v,eM=new v,eq=new v,eB=new v,eP=new g,eA=[],eF=new v,eI=new v,eT=new v,eN=new v,eR=new v,eL=new v,ej=new v,ek=new v,eW=new v,eO=[new v,new v,new v,new v,new v,new v],eV=new v,eD=new v,eH=new v,eG=new v,eY=new v,eX=new v,eU=new v,e_=new v,eZ=new v,eK=new v,e$=new v,eQ=new v,eJ=new v,e0=new v;new v,new v;const e1=new v,e2=new v,e5=new v,e3=new v,e6=new v,e4=new v,e7=new v,e8=new v,e9=new v,it=new v,ie=new C,ii=new v;new v;const is=new v,io=new v,ir=new v,ia=new v,il=new v,ih=[0],ic=new v,id=new v;class iu{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){let i=e;e=t,t=i}return t<<16|e}set(t,e){let i=this.getKey(t,e),s=this.current,o=0;for(;i>s[o];)o++;if(i!==s[o]){for(let t=s.length-1;t>=o;t--)s[t+1]=s[t];s[o]=i}}tick(){let t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){let i=this.current,s=this.previous,o=i.length,n=s.length,r=0;for(let e=0;e<o;e++){let o=i[e];for(;o>s[r];)r++;o===s[r]||ip(t,o)}r=0;for(let t=0;t<n;t++){let o=s[t];for(;o>i[r];)r++;i[r]===o||ip(e,o)}}}function ip(t,e){t.push((4294901760&e)>>16,65535&e)}const iy=(t,e)=>t<e?`${t}-${e}`:`${e}-${t}`;class iv{constructor(){this.data={keys:[]}}get(t,e){let i=iy(t,e);return this.data[i]}set(t,e,i){let s=iy(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=i}delete(t,e){let i=iy(t,e),s=this.data.keys.indexOf(i);-1!==s&&this.data.keys.splice(s,1),delete this.data[i]}reset(){let t=this.data,e=t.keys;for(;e.length>0;){let i=e.pop();delete t[i]}}}new g;const im=new tl,iw=globalThis.performance||{};if(!iw.now){let t=Date.now();iw.timing&&iw.timing.navigationStart&&(t=iw.timing.navigationStart),iw.now=()=>Date.now()-t}new v;const ig={type:"postStep"},ib={type:"preStep"},ix={type:O.COLLIDE_EVENT_NAME,body:null,contact:null},iE=[],iz=[],iC=[],iS=[],iM=[],iq=[],iB={type:"beginContact",bodyA:null,bodyB:null},iP={type:"endContact",bodyA:null,bodyB:null},iA={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},iF={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};c("e93rA");var iI=c("4vgtB"),u=c("dbKDE");const iT=new class extends z{constructor(t){void 0===t&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==t.quatNormalizeSkip?t.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==t.quatNormalizeFast&&t.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new v,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new v,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=void 0!==t.broadphase?t.broadphase:new tn,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==t.solver?t.solver:new t8,this.constraints=[],this.narrowphase=new en(this),this.collisionMatrix=new E,this.collisionMatrixPrevious=new E,this.bodyOverlapKeeper=new iu,this.shapeOverlapKeeper=new iu,this.contactmaterials=[],this.contactMaterialTable=new iv,this.defaultMaterial=new t4("default"),this.defaultContactMaterial=new t6(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){let t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){let e=this.constraints.indexOf(t);-1!==e&&this.constraints.splice(e,1)}rayTest(t,e,i){i instanceof tr?this.raycastClosest(t,e,{skipBackfaces:!0},i):this.raycastAll(t,e,{skipBackfaces:!0},i)}raycastAll(t,e,i,s){return void 0===i&&(i={}),i.mode=tl.ALL,i.from=t,i.to=e,i.callback=s,im.intersectWorld(this,i)}raycastAny(t,e,i,s){return void 0===i&&(i={}),i.mode=tl.ANY,i.from=t,i.to=e,i.result=s,im.intersectWorld(this,i)}raycastClosest(t,e,i,s){return void 0===i&&(i={}),i.mode=tl.CLOSEST,i.from=t,i.to=e,i.result=s,im.intersectWorld(this,i)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof O&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;let e=this.bodies.length-1,i=this.bodies,s=i.indexOf(t);if(-1!==s){i.splice(s,1);for(let t=0;t!==i.length;t++)i[t].index=t;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){let e=this.bodies;for(let i=0;i<e.length;i++){let s=e[i].shapes;for(let e=0;e<s.length;e++){let i=s[e];if(i.id===t)return i}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){let e=this.contactmaterials.indexOf(t);-1!==e&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){void 0===t&&(t=1/60),void 0===e&&(e=10);let i=iw.now()/1e3;if(this.lastCallTime){let s=i-this.lastCallTime;this.step(t,s,e)}else this.step(t,void 0,e);this.lastCallTime=i}step(t,e,i){if(void 0===i&&(i=10),void 0===e)this.internalStep(t),this.time+=t;else{this.accumulator+=e;let s=iw.now(),o=0;for(;this.accumulator>=t&&o<i&&(this.internalStep(t),this.accumulator-=t,o++,!(iw.now()-s>1e3*t)););this.accumulator=this.accumulator%t;let n=this.accumulator/t;for(let t=0;t!==this.bodies.length;t++){let e=this.bodies[t];e.previousPosition.lerp(e.position,n,e.interpolatedPosition),e.previousQuaternion.slerp(e.quaternion,n,e.interpolatedQuaternion),e.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;let e=this.contacts,i=this.bodies.length,s=this.bodies,o=this.solver,n=this.gravity,r=this.doProfiling,a=this.profile,l=O.DYNAMIC,h=-1/0,c=this.constraints;n.length();let d=n.x,u=n.y,p=n.z,y=0;for(r&&(h=iw.now()),y=0;y!==i;y++){let t=s[y];if(t.type===l){let e=t.force,i=t.mass;e.x+=i*d,e.y+=i*u,e.z+=i*p}}for(let t=0,e=this.subsystems.length;t!==e;t++)this.subsystems[t].update();r&&(h=iw.now()),iC.length=0,iS.length=0,this.broadphase.collisionPairs(this,iC,iS),r&&(a.broadphase=iw.now()-h);let v=c.length;for(y=0;y!==v;y++){let t=c[y];if(!t.collideConnected)for(let e=iC.length-1;e>=0;e-=1)(t.bodyA===iC[e]&&t.bodyB===iS[e]||t.bodyB===iC[e]&&t.bodyA===iS[e])&&(iC.splice(e,1),iS.splice(e,1))}this.collisionMatrixTick(),r&&(h=iw.now());let m=e.length;for(y=0;y!==m;y++)iE.push(e[y]);e.length=0;let w=this.frictionEquations.length;for(y=0;y!==w;y++)iz.push(this.frictionEquations[y]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(iC,iS,this,e,iE,this.frictionEquations,iz),r&&(a.narrowphase=iw.now()-h),r&&(h=iw.now()),y=0;y<this.frictionEquations.length;y++)o.addEquation(this.frictionEquations[y]);let f=e.length;for(let t=0;t!==f;t++){let i=e[t],s=i.bi,n=i.bj,r=i.si,a=i.sj;(s.material&&n.material&&this.getContactMaterial(s.material,n.material)||this.defaultContactMaterial).friction,s.material&&n.material&&(s.material.friction>=0&&n.material.friction>=0&&(s.material.friction,n.material.friction),s.material.restitution>=0&&n.material.restitution>=0&&(i.restitution=s.material.restitution*n.material.restitution)),o.addEquation(i),s.allowSleep&&s.type===O.DYNAMIC&&s.sleepState===O.SLEEPING&&n.sleepState===O.AWAKE&&n.type!==O.STATIC&&n.velocity.lengthSquared()+n.angularVelocity.lengthSquared()>=2*n.sleepSpeedLimit**2&&(s.wakeUpAfterNarrowphase=!0),n.allowSleep&&n.type===O.DYNAMIC&&n.sleepState===O.SLEEPING&&s.sleepState===O.AWAKE&&s.type!==O.STATIC&&s.velocity.lengthSquared()+s.angularVelocity.lengthSquared()>=2*s.sleepSpeedLimit**2&&(n.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(s,n,!0),this.collisionMatrixPrevious.get(s,n)||(ix.body=n,ix.contact=i,s.dispatchEvent(ix),ix.body=s,n.dispatchEvent(ix)),this.bodyOverlapKeeper.set(s.id,n.id),this.shapeOverlapKeeper.set(r.id,a.id)}for(this.emitContactEvents(),r&&(a.makeContactConstraints=iw.now()-h,h=iw.now()),y=0;y!==i;y++){let t=s[y];t.wakeUpAfterNarrowphase&&(t.wakeUp(),t.wakeUpAfterNarrowphase=!1)}for(y=0,v=c.length;y!==v;y++){let t=c[y];t.update();for(let e=0,i=t.equations.length;e!==i;e++){let i=t.equations[e];o.addEquation(i)}}o.solve(t,this),r&&(a.solve=iw.now()-h),o.removeAllEquations();let g=Math.pow;for(y=0;y!==i;y++){let e=s[y];if(e.type&l){let i=g(1-e.linearDamping,t),s=e.velocity;s.scale(i,s);let o=e.angularVelocity;if(o){let i=g(1-e.angularDamping,t);o.scale(i,o)}}}this.dispatchEvent(ib),r&&(h=iw.now());let b=this.stepnumber%(this.quatNormalizeSkip+1)==0,x=this.quatNormalizeFast;for(y=0;y!==i;y++)s[y].integrate(t,b,x);this.clearForces(),this.broadphase.dirty=!0,r&&(a.integrate=iw.now()-h),this.stepnumber+=1,this.dispatchEvent(ig);let E=!0;if(this.allowSleep)for(y=0,E=!1;y!==i;y++){let t=s[y];t.sleepTick(this.time),t.sleepState!==O.SLEEPING&&(E=!0)}this.hasActiveBodies=E}emitContactEvents(){let t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(iM,iq),t){for(let t=0,e=iM.length;t<e;t+=2)iB.bodyA=this.getBodyById(iM[t]),iB.bodyB=this.getBodyById(iM[t+1]),this.dispatchEvent(iB);iB.bodyA=iB.bodyB=null}if(e){for(let t=0,e=iq.length;t<e;t+=2)iP.bodyA=this.getBodyById(iq[t]),iP.bodyB=this.getBodyById(iq[t+1]),this.dispatchEvent(iP);iP.bodyA=iP.bodyB=null}iM.length=iq.length=0;let i=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((i||s)&&this.shapeOverlapKeeper.getDiff(iM,iq),i){for(let t=0,e=iM.length;t<e;t+=2){let e=this.getShapeById(iM[t]),i=this.getShapeById(iM[t+1]);iA.shapeA=e,iA.shapeB=i,e&&(iA.bodyA=e.body),i&&(iA.bodyB=i.body),this.dispatchEvent(iA)}iA.bodyA=iA.bodyB=iA.shapeA=iA.shapeB=null}if(s){for(let t=0,e=iq.length;t<e;t+=2){let e=this.getShapeById(iq[t]),i=this.getShapeById(iq[t+1]);iF.shapeA=e,iF.shapeB=i,e&&(iF.bodyA=e.body),i&&(iF.bodyB=i.body),this.dispatchEvent(iF)}iF.bodyA=iF.bodyB=iF.shapeA=iF.shapeB=null}}clearForces(){let t=this.bodies,e=t.length;for(let i=0;i!==e;i++){let e=t[i];e.force,e.torque,e.force.set(0,0,0),e.torque.set(0,0,0)}}}({gravity:new v(0,-19.81,0)}),iN=new t4,iR=new d.PlaneGeometry(250,250),iL=new d.MeshStandardMaterial({color:16777215,side:d.DoubleSide,map:iI.grass}),ij=new d.Mesh(iR,iL);(0,u.scene).add(ij);const ik=new O({shape:new R(new v(125,125,.1)),type:O.STATIC,material:iN});ik.quaternion.setFromEuler(Math.PI/2,0,0),iT.addBody(ik);const iW=new t4,iO=new d.SphereGeometry(5),iV=new d.MeshLambertMaterial({color:16777215,map:iI.bola}),iD=new d.Mesh(iO,iV);(0,u.scene).add(iD);const iH=new O({mass:50,shape:new class extends q{constructor(t){if(super({type:q.types.SPHERE}),this.radius=void 0!==t?t:1,this.radius<0)throw Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(t,e){void 0===e&&(e=new v);let i=2*t*this.radius*this.radius/5;return e.x=i,e.y=i,e.z=i,e}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(t,e,i,s){let o=this.radius,n=["x","y","z"];for(let e=0;e<n.length;e++){let r=n[e];i[r]=t[r]-o,s[r]=t[r]+o}}}(5),position:new v(0,15,0),material:iW});iT.addBody(iH);const iG=new t6(iN,iW,{friction:1,restitution:0});iH.linearDamping=.25,iT.addContactMaterial(iG);const iY={mesh:ij,body:ik},iX={mesh:iD,body:iH,phys:iW},iU=1/60;c("e93rA");var iI=c("4vgtB"),d=c("jPmIf");c("e93rA");var u=c("dbKDE");function i_({geoWidth:t,geoHeight:e,geoDepth:i,bodyPositionX:s,bodyPositionY:o,bodyPositionZ:n,transparent:r,opacity:a,color:l,map:h}){let c=new d.BoxGeometry(t,e,i),p=new d.MeshStandardMaterial({color:l||3355443,side:d.DoubleSide,transparent:!!r,opacity:a||1,map:h}),y=new d.Mesh(c,p);(0,u.scene).add(y);let m=new t4,w=new O({shape:new R(new v(t/2,e/2,i/2)),position:new v(s,o||e/2,n),type:O.STATIC,material:m});return iT.addBody(w),{mesh:y,physMat:m,body:w}}const iZ=i_({geoWidth:265,geoHeight:125,geoDepth:10,bodyPositionX:125,bodyPositionZ:0,map:iI.brick}),iK=new t6(iZ.physMat,iX.phys,{friction:1,restitution:2});iT.addContactMaterial(iK),iZ.body.quaternion.setFromEuler(0,-.5*Math.PI,0);const i$=i_({geoWidth:265,geoHeight:125,geoDepth:10,bodyPositionX:-125,bodyPositionZ:0,map:iI.brick}),iQ=new t6(i$.physMat,iX.phys,{friction:1,restitution:2});iT.addContactMaterial(iQ),i$.body.quaternion.setFromEuler(0,-.5*Math.PI,0);const iJ=i_({geoWidth:265,geoHeight:125,geoDepth:10,bodyPositionX:0,bodyPositionZ:125,map:iI.brick}),i0=new t6(iJ.physMat,iX.phys,{friction:1,restitution:2});iT.addContactMaterial(i0);const i1=i_({geoWidth:265,geoHeight:125,geoDepth:10,bodyPositionX:0,bodyPositionZ:-125,map:iI.brick}),i2=new t6(i1.physMat,iX.phys,{friction:1,restitution:2});iT.addContactMaterial(i2);const i5=i_({geoWidth:260,geoHeight:260,geoDepth:1,bodyPositionX:0,bodyPositionZ:0,opacity:.1,transparent:!0,color:4080});i5.body.position.y=125;const i3=new t6(i5.physMat,iX.phys,{friction:.5});i5.body.quaternion.setFromEuler(Math.PI/2,0,0),iT.addContactMaterial(i3);var d=c("jPmIf");c("e93rA");var u=c("dbKDE"),iI=c("4vgtB");const i6=i_({geoWidth:6,geoHeight:25,geoDepth:66.5,bodyPositionX:86,bodyPositionZ:51,color:16777215,map:iI.quartzo});i6.body.quaternion.setFromEuler(0,Math.PI/2,0);const i4=new t6(i6.physMat,iX.phys,{restitution:0});iT.addContactMaterial(i4);const i7=i_({geoWidth:6,geoHeight:25,geoDepth:72,bodyPositionX:52,bodyPositionZ:84,color:16777215,map:iI.quartzo}),i8=new t6(i7.physMat,iX.phys,{restitution:0});iT.addContactMaterial(i8);const i9=i_({geoWidth:.5,geoHeight:85,geoDepth:70,bodyPositionX:23,bodyPositionY:1,bodyPositionZ:90,color:13421772,map:iI.madeira}),st=new t6(i9.physMat,iX.phys,{friction:1e3});i9.body.quaternion.setFromEuler(1.5*Math.PI,1.27*Math.PI,0),iT.addContactMaterial(st);const se=i_({geoWidth:.5,geoHeight:65.5,geoDepth:67.5,bodyPositionX:87.5,bodyPositionY:20,bodyPositionZ:87.5,color:16777215,map:iI.linkedin}),si=new t6(se.physMat,iX.phys,{restitution:.5}),ss=new d.PointLight(4080,1e4,300);ss.position.set(90,20,90),(0,u.scene).add(ss),se.body.quaternion.setFromEuler(1.5*Math.PI,1.5*Math.PI,0),console.log(se.body),iT.addContactMaterial(si);var d=c("jPmIf");c("e93rA");var u=c("dbKDE"),iI=c("4vgtB");const so=i_({geoWidth:50,geoHeight:10,geoDepth:2.5,bodyPositionX:-75,bodyPositionZ:-100,color:7829367,map:iI.pedregulho}),sn=new t6(so.physMat,iX.phys,{restitution:0});iT.addContactMaterial(sn);const sr=i_({geoWidth:20,geoHeight:10,geoDepth:2.5,bodyPositionX:-110,bodyPositionZ:-75,color:7829367,map:iI.pedregulho}),sa=new t6(sr.physMat,iX.phys,{restitution:0});sr.body.quaternion.setFromEuler(0,0,0),iT.addContactMaterial(sa);const sl=i_({geoWidth:25,geoHeight:10,geoDepth:2.5,bodyPositionX:-100,bodyPositionZ:-87.5,color:7829367,map:iI.pedregulho}),sh=new t6(sl.physMat,iX.phys,{restitution:0});sl.body.quaternion.setFromEuler(0,1.5*Math.PI,0),iT.addContactMaterial(sh);const sc=i_({geoWidth:50,geoHeight:10,geoDepth:2.5,bodyPositionX:-75,bodyPositionZ:-50,color:7829367,map:iI.pedregulho}),sd=new t6(sc.physMat,iX.phys,{restitution:0});sc.body.quaternion.setFromEuler(0,0,0),iT.addContactMaterial(sd);const su=i_({geoWidth:50,geoHeight:10,geoDepth:2.5,bodyPositionX:-50,bodyPositionZ:-75,color:7829367,map:iI.pedregulho}),sp=new t6(su.physMat,iX.phys,{restitution:0});su.body.quaternion.setFromEuler(0,1.5*Math.PI,0),iT.addContactMaterial(sp);const sy=i_({geoWidth:.5,geoHeight:50,geoDepth:50,bodyPositionX:-75,bodyPositionY:1,bodyPositionZ:-75,color:2105376,map:iI.github}),sv=new t6(sy.physMat,iX.phys,{restitution:0}),sm=new d.PointLight(16777215,3500,300);sm.position.set(-85,30,-85),(0,u.scene).add(sm),sy.body.quaternion.setFromEuler(1.5*Math.PI,1.5*Math.PI,0),console.log(sy.body),iT.addContactMaterial(sv);let sw=!1;(0,u.camera).position.set(0,140,120),(0,u.renderer).setAnimationLoop(function(){iT.step(iU),iY.mesh.position.copy(iY.body.position),iY.mesh.quaternion.copy(iY.body.quaternion),iX.mesh.position.copy(iX.body.position),iX.mesh.quaternion.copy(iX.body.quaternion),iZ.mesh.position.copy(iZ.body.position),iZ.mesh.quaternion.copy(iZ.body.quaternion),i$.mesh.position.copy(i$.body.position),i$.mesh.quaternion.copy(i$.body.quaternion),iJ.mesh.position.copy(iJ.body.position),iJ.mesh.quaternion.copy(iJ.body.quaternion),i1.mesh.position.copy(i1.body.position),i1.mesh.quaternion.copy(i1.body.quaternion),i5.mesh.position.copy(i5.body.position),i5.mesh.quaternion.copy(i5.body.quaternion),i6.mesh.position.copy(i6.body.position),i6.mesh.quaternion.copy(i6.body.quaternion),i7.mesh.position.copy(i7.body.position),i7.mesh.quaternion.copy(i7.body.quaternion),i9.mesh.position.copy(i9.body.position),i9.mesh.quaternion.copy(i9.body.quaternion),se.mesh.position.copy(se.body.position),se.mesh.quaternion.copy(se.body.quaternion),so.mesh.position.copy(so.body.position),so.mesh.quaternion.copy(so.body.quaternion),sr.mesh.position.copy(sr.body.position),sr.mesh.quaternion.copy(sr.body.quaternion),sl.mesh.position.copy(sl.body.position),sl.mesh.quaternion.copy(sl.body.quaternion),sc.mesh.position.copy(sc.body.position),sc.mesh.quaternion.copy(sc.body.quaternion),su.mesh.position.copy(su.body.position),su.mesh.quaternion.copy(su.body.quaternion),sy.mesh.position.copy(sy.body.position),sy.mesh.quaternion.copy(sy.body.quaternion);let t=new d.Vector3(iX.body.position.x,iX.body.position.y,iX.body.position.z);(0,u.camera).lookAt(t),iX.mesh.position.z>53&&iX.mesh.position.x>53&&setTimeout(()=>{sw||(window.location.href="https://www.linkedin.com/in/victor-lis-bronzo/",sw=!0)},2e3),iX.mesh.position.z>-102&&iX.mesh.position.z<-57&&iX.mesh.position.x<-44&&iX.mesh.position.x>-102&&setTimeout(()=>{sw||(window.location.href="https://www.github.com/Victor-Lis",sw=!0)},2e3),(0,u.renderer).render(u.scene,u.camera)});const sf={left:document.querySelector("#left"),right:document.querySelector("#right"),up:document.querySelector("#up"),down:document.querySelector("#down")};function sg({direction:t}){1==t?iX.body.angularVelocity.set(10,0,0):2==t?iX.body.angularVelocity.set(-10,0,0):3==t?iX.body.angularVelocity.set(0,0,10):iX.body.angularVelocity.set(0,0,-10)}sf.left.addEventListener("click",t=>{sg({direction:3})}),sf.right.addEventListener("click",t=>{sg({direction:4})}),sf.up.addEventListener("click",t=>{sg({direction:2})}),sf.down.addEventListener("click",t=>{sg({direction:1})}),window.addEventListener("keydown",t=>{"A"==t.key.toUpperCase()&&sg({direction:3}),"D"==t.key.toUpperCase()&&sg({direction:4}),"W"==t.key.toUpperCase()&&sg({direction:2}),"S"==t.key.toUpperCase()&&sg({direction:1})});
//# sourceMappingURL=index.dcd63da7.js.map
